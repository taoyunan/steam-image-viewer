<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>枫小痕自己的steamdb</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.css" />
<style>
 @import url('https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap');
 /* ... CSS ... */
 * { box-sizing: border-box; }
 body {
 background: #121417; color: #e0e0e0; font-family: 'Roboto Slab', "微软雅黑", sans-serif;
 display: flex; flex-direction: column; align-items: center;
 padding: 25px 15px 40px; min-height: 100vh;
 }
 .main-container, #imageInspector, #apiViewerContainer {
 width: 100%; max-width: 1200px;
 }
 .header-container {
 display: flex; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 1200px;
 }
 h1 {
 margin: 0; font-weight: 700; font-size: 2.4rem; letter-spacing: 2px;
 color: #60a5fa; text-shadow: 0 0 10px #60a5faaa;
 }
 .header-controls {
    margin-left: auto; display: flex; align-items: center; gap: 20px;
 }
 .controls {
 display: flex; gap: 12px; margin-bottom: 15px;
 width: 100%; max-width: 820px; flex-wrap: wrap; align-items: center;
 }
 input, button, select, textarea {
 border-radius: 8px; border: none; font-size: 14px;
 outline: none; transition: all 0.25s ease; font-weight: 500;
 }
 input[type="text"], input[type="number"], select, textarea {
 background: #23262a; color: #ddd; padding: 8px 12px;
 box-shadow: inset 0 0 6px #0008;
 }
 input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
 background: #2b2e34; box-shadow: inset 0 0 8px #60a5faaa; color: #eef3ff;
 }
 #appId {
 height: 36px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 button {
 background: #3b82f6; color: white; cursor: pointer; padding: 10px 22px;
 font-weight: 700; box-shadow: 0 4px 15px #3b82f6bb; flex: none;
 }
 button:disabled { background: #606c8f; cursor: not-allowed; box-shadow: none; }
 button:hover:not(:disabled) { background: #2563eb; box-shadow: 0 6px 20px #2563ebcc; }
 #customText {
 resize: vertical; min-height: 60px; max-height: 120px;
 padding: 8px 12px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 input[type="color"] {
 min-width: 48px; height: 36px; padding: 2px; cursor: pointer; flex: none;
 border-radius: 8px; border: 2px solid transparent; transition: border-color 0.2s ease;
 background: #23262a;
 }
 input[type="color"]:focus { border-color: #60a5fa; }
 input[type="number"] { width: 80px; height: 36px; text-align: center; flex: none; }
 select { width: 150px; cursor: pointer; height: 36px; flex: none; }
 #canvas-container {
 background: #171c29; width: 100%; max-width: 1200px; height: 278px;
 position: relative; overflow: visible; box-shadow: 0 0 25px #2563eb44 inset;
 border-radius: 12px; cursor: grab; margin: 0 auto;
 }
 canvas { display: block; user-select: none; border-radius: 12px; }
 .slider-container, .main-container .controls {
 margin-left: auto; margin-right: auto;
 }
 .slider-container {
 margin-top: 15px; width: 100%; max-width: 600px; display: flex;
 align-items: center; gap: 15px; color: #bbb;
 }
 input[type="range"] {
 flex: 1; -webkit-appearance: none; height: 6px; border-radius: 6px;
 background: #4b6cb7; cursor: pointer; transition: background-color 0.2s ease;
 }
 input[type="range"]:hover { background: #3b82f6; }
 input[type="range"]::-webkit-slider-thumb {
 -webkit-appearance: none; width: 16px; height: 16px; background: #60a5fa;
 border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px #60a5faaa;
 transition: background-color 0.2s ease;
 }
 input[type="range"]:active::-webkit-slider-thumb { background: #2563eb; box-shadow: 0 0 12px #2563ebcc; }
 #scalePercent, #overlayPercent { min-width: 45px; font-weight: 600; color: #60a5fa; }
 .status-box { margin-top: 18px; min-height: 1.5em; text-align: center; font-weight: 700; width: 100%; max-width: 820px; }
 #error { color: #ef4444; }
 #loading { color: #60a5fa; }
 #tutorial {
 position: fixed; top: 20px; right: 20px; width: 380px; z-index: 1000;
 padding: 20px 25px; background: #1e2433ee; backdrop-filter: blur(8px);
 border-radius: 14px; font-size: 14px; line-height: 1.7; border: 1px solid #2e3a59;
 box-shadow: 0 8px 30px rgba(0,0,0,0.4); max-height: calc(100vh - 40px);
 overflow-y: auto; transition: opacity 0.3s ease, transform 0.3s ease;
 }
 #tutorial.hidden {
 opacity: 0; transform: translateX(20px); pointer-events: none;
 }
 .tutorial-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
 #tutorial h2 { margin: 0; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; font-size: 20px; }
 #tutorial h3 { margin: 20px 0 10px; color: #82b9ff; font-weight: 700; border-bottom: 1px solid #2e3a59; padding-bottom: 5px;}
 #tutorial ul { list-style-type: disc; padding-left: 20px; color: #ccc; margin: 0; }
 #tutorial ul li { margin-bottom: 10px; }
 #tutorial p { margin: 10px 0; }
 #tutorial code, #tutorial kbd { background: #121417; padding: 2px 5px; border-radius: 4px; font-family: monospace; color: #ffb86c; border: 1px solid #444; }
 .toggle-tutorial-btn {
 background: none; border: 1px solid #4b6cb7; color: #bbb;
 padding: 4px 10px; font-size: 12px; cursor: pointer; box-shadow: none;
 }
 #showTutorialBtn {
 font-size: 20px; padding: 0 10px; background: #23262a;
 border: 1px solid #2e3a59; box-shadow: none;
 }
 #imageInspector, #apiViewerContainer {
 text-align: left; margin-top: 36px; padding: 20px 25px; background: #1e2433;
 border-radius: 14px; font-size: 15px; line-height: 1.7;
 box-shadow: 0 0 20px #1e2433; border: 1px solid #2e3a59;
 }
 #imageInspector h3, #apiViewerContainer h3 { margin: 0 0 15px; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; }
 .inspector-controls { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
 #urlsBox { width: 100%; min-height: 120px; resize: vertical; margin-bottom: 15px; }
 .url-actions-container { margin-top: 25px; }
 .category { margin-bottom: 20px; padding: 15px; border-radius: 12px; background: rgba(0,0,0,0.2); border: 1px solid #2e3a59; }
 .category-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
 .category-header h4 { margin: 0; font-size: 16px; font-weight: bold; color: #fff; background: #60a5fa; display: inline-block; padding: 4px 10px; border-radius: 6px; }
 .toggle-btn { font-size: 12px; padding: 4px 10px; background: transparent; border: 1px solid #4b6cb7; color: #bbb; box-shadow: none; }
 .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px; }
 .card { background: #23262a; padding: 8px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 8px; align-items: center; transition: all 0.2s ease; border: 2px solid transparent; }
 .card:hover { transform: translateY(-4px); box-shadow: 0 6px 20px rgba(96,165,250,0.3); }
 .card.highlight-schinese {
 border-color: #60a5fa; box-shadow: 0 0 15px rgba(96, 165, 250, 0.6);
 }
 .thumb {
 width: 100%; height: 120px; object-fit: contain; border-radius: 8px;
 background: #121214; cursor: pointer;
 }
 .card .meta { width: 100%; font-size: 13px; color: #9aa4b2; text-align: center; }
 .card .actions { display: flex; gap: 8px; width: 100%; flex-wrap: wrap; justify-content: center; }
 .card .actions button { font-size: 12px; padding: 6px 10px; background: #4b6cb7; box-shadow: none; }
 .card .actions button:hover:not(:disabled) { background: #3b82f6; }

 #api-table {
    width: 100%; border-collapse: collapse; font-size: 14px; margin-top: 15px;
 }
 #api-table td {
    padding: 10px 8px; vertical-align: top; border-bottom: 1px solid #2e3a59;
 }
 #api-table tr:last-child td { border-bottom: none; }
 #api-table td:nth-child(1) { font-weight: 700; color: #aeb9c7; width: 220px; word-break: break-word; }
 #api-table td:nth-child(2) { color: #e0e0e0; word-break: break-word; }
 #api-table td:nth-child(2) :is(ul, ol) { padding-left: 20px; }
 #api-table td:nth-child(2) img { max-width: 100%; border-radius: 6px; }
 .api-game-title { font-size: 24px; font-weight: bold; color: #fff; margin: 0; }
 .api-game-title-zh { font-size: 28px; font-weight: bold; color: #60a5fa; text-shadow: 0 0 10px #60a5faaa; margin: 5px 0 0 0; }
 #api-table .api-section-header td, #api-table .api-title-header td {
    font-size: 18px; font-weight: bold; color: #60a5fa;
    padding-top: 25px !important; padding-bottom: 12px !important;
    border-bottom: 1px solid #60a5fa;
 }
 #api-table .api-title-header td { border: none; padding-bottom: 20px !important; }
 #api-table a { color: #60a5fa; text-decoration: none; }
 #api-table a:hover { text-decoration: underline; }
 #api-table code { background: #121417; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
 .language-table { width: 100%; margin-top: 5px; border: 1px solid #2e3a59; border-radius: 6px; border-collapse: separate; border-spacing: 0; }
 .language-table th, .language-table td { text-align: left; padding: 6px 8px; border-bottom: 1px solid #2e3a59; }
 .language-table tr:last-child td { border-bottom: none; }
 .language-table th { color: #aeb9c7; background: #23262a; }
 .language-table .support-cell { text-align: center; }
 .check-mark { color: #4ade80; font-weight: bold; }
 .platform-icon { height: 1em; vertical-align: text-bottom; margin-right: 4px; }

 #cropModal {
     position: fixed; top: 0; left: 0; width: 100%; height: 100%;
     background: rgba(0, 0, 0, 0.8); z-index: 2000;
     display: none; align-items: center; justify-content: center;
     backdrop-filter: blur(5px);
 }
 #cropContainer {
     background: #1e2433; padding: 20px; border-radius: 14px;
     max-width: 90vw; max-height: 90vh; display: flex; flex-direction: column;
     box-shadow: 0 8px 30px rgba(0,0,0,0.4); border: 1px solid #2e3a59;
 }
 #cropImageContainer { max-width: 80vw; max-height: 70vh; }
 #cropImage { display: block; max-width: 100%; max-height: 100%; }
 .crop-controls { margin-top: 15px; text-align: center; display: flex; flex-direction: column; gap: 10px; justify-content: center;}
 .crop-controls .row { display: flex; gap: 10px; justify-content: center; align-items: center; }
 .crop-controls .row button, .crop-controls button { font-size: 12px; padding: 6px 12px;}
 .crop-controls input[type="number"] { width: 70px; height: 30px; }

</style>
</head>
<body>

<div id="tutorial" class="hidden">
    <div class="tutorial-header">
        <h2>使用说明</h2>
        <button id="hideTutorialBtn" class="toggle-tutorial-btn">关闭</button>
    </div>
    <p>这是一个为游戏编辑和社区运营人员设计的在线工具，旨在快速获取和处理 Steam 游戏的各类图片素材。</p>

    <h3>✨ 主要功能</h3>
    <h4>自定义横幅生成器</h4>
    <ul>
        <li><strong>智能加载</strong>：自动加载游戏的高清背景图，并优先加载简体中文版 (<code>schinese</code>) 的 Logo。</li>
        <li><strong>默认居中</strong>：Logo 默认放置在画布正中央，方便拖动调整。</li>
        <li><strong>自由布局与快捷键</strong>：
            <ul>
                <li>直接拖动 Logo 或文字进行微调。</li>
                <li>按住 <kbd>Shift</kbd> 键可同步拖动 Logo 和文字。</li>
                <li>当元素重叠时，按住 <kbd>Ctrl</kbd> 键可强制只拖动文字层。</li>
            </ul>
        </li>
    </ul>

    <h4>图片探查器</h4>
    <ul>
        <li><strong>全面搜刮</strong>：自动解析 API 数据，找出所有与该游戏相关的图片与视频资源。</li>
        <li><strong>智能分组</strong>：将所有图片按分辨率进行归类，并将视频单独分组。</li>
        <li><strong>截图置顶</strong>：<code>1920x1080</code> 的图片会被识别为“截图”并置顶显示。</li>
        <li><strong>视频支持</strong>：新增“宣传影像”分类，可预览封面、播放和下载视频。</li>
        <li><strong>打包下载截图</strong>：专用按钮一键将所有高清商店截图打包为 ZIP 文件下载。</li>
    </ul>

    <h4>高级图片裁剪</h4>
    <ul>
        <li><strong>手动精裁</strong>：内置强大的图片裁剪工具，支持自由选择、固定比例裁剪。</li>
        <li><strong>实时比例</strong>：当输入目标分辨率时，裁剪框会自动锁定为该宽高比。</li>
        <li><strong>打包裁剪</strong>：提供“<strong>自动裁剪并打包</strong>”功能，一键完成以下任务并打包成 ZIP 下载：
            <ol>
                <li>自动寻找 <code>920x430</code> 的横向主图（优先中文版）。</li>
                <li>将其自动裁剪为 <code>474x242</code>, <code>497x278</code>, <code>300x180</code> 三种尺寸。</li>
                <li>自动寻找并包含 <code>300x450</code> 的纵向封面图（优先中文版）。</li>
            </ol>
        </li>
    </ul>
    
    <h4>API 数据浏览器</h4>
    <ul>
        <li><strong>中文优先</strong>：优先从中文商店获取“关于游戏”、“简介”等文本信息。</li>
        <li><strong>结构化展示</strong>：将原始 JSON 数据整理成清晰、易读的表格。</li>
        <li><strong>智能汉化</strong>：将关键字段和语言列表等内容进行汉化，提升阅读体验。</li>
        <li><strong>新增信息</strong>：现在包含“关于游戏”、“简介”、“PC配置要求”等更多详细信息。</li>
    </ul>
</div>


<div class="main-container">
 <div class="header-container">
     <h1>枫小痕自己的steamdb</h1>
     <div class="header-controls">
        <a href="https://github.com/taoyunan/steam-image-viewer" target="_blank" title="查看 GitHub 仓库" style="color: #bbb; text-decoration: none; font-weight: 500; font-size: 16px;">GitHub</a>
        <button id="showTutorialBtn" title="显示教程">?</button>
     </div>
 </div>

 <div class="controls">
    <input type="text" id="appId" placeholder="输入 Steam App ID 或商店链接" autocomplete="off" />
    <button id="fetchBtn" style="margin-left: 12px;">获取</button>
    <button id="saveBtn" disabled style="margin-left: auto;">保存图片</button>
    <button id="goToStoreBtn" disabled>前往商店</button>
 </div>

 <div class="controls">
 <textarea id="customText" placeholder="输入自定义文字（支持多行）"></textarea>
 <input type="color" id="textColor" value="#ffffff" title="文字颜色" />
 <input type="number" id="textSize" value="24" min="8" max="200" title="文字大小" />
 <input type="number" id="lineSpacing" value="5" min="0" max="100" title="行间距" />
 <select id="textFont" title="字体">
 <option value="微软雅黑">微软雅黑</option> <option value="黑体">黑体</option> <option value="Arial">Arial</option> <option value="Times New Roman">Times New Roman</option>
 </select>
 </div>
 <div id="canvas-container">
 <canvas id="heroCanvas" width="1200" height="278" title="拖动Logo或文字微调位置"></canvas>
 </div>
 <div class="slider-container">
 <label for="scaleSlider">缩放 Logo:</label>
 <input type="range" id="scaleSlider" min="10" max="200" value="100" disabled />
 <span id="scalePercent">100%</span>
 </div>
 <div class="controls slider-container" style="margin-top: 15px;">
 <label for="overlaySlider">背景渐变:</label>
 <input type="range" id="overlaySlider" min="0" max="100" value="40" />
 <span id="overlayPercent">40%</span>
 <input type="color" id="gradientColor" value="#000000" title="渐变颜色" />
 <select id="gradientDirection" title="渐变方向">
 <option value="top-to-bottom">从上到下</option> <option value="bottom-to-top">从下到上</option> <option value="left-to-right">从左到右</option> <option value="right-to-left">从右到左</option> <option value="tl-to-br">左上到右下</option> <option value="tr-to-bl">右上到左下</option> <option value="bl-to-tr">左下到右上</option> <option value="br-to-tl">右下到左上</option>
 </select>
 </div>
 <div class="status-box"> <div id="loading"></div> <div id="error"></div> </div>
</div>

<div class="controls" style="justify-content: center; margin-top: 20px;">
    <button id="toggleApiBtn" style="display: none;">查看 API 数据</button>
</div>

<div id="apiViewerContainer" style="display: none;">
 <h3>API 数据浏览器</h3>
 <table id="api-table"></table>
</div>

<div id="imageInspector" style="display: none;">
 <h3>图片探查器</h3>
  <div class="inspector-controls">
     <button id="autoCropBtn" style="background-color: #22c55e;">自动裁剪并打包</button>
     <button id="downloadScreenshotsBtn" style="background-color: #0ea5e9;">打包下载所有截图</button>
  </div>
 <div id="imageList"></div>
 <div class="url-actions-container">
     <div class="inspector-controls">
         <button id="copyAllBtn">复制全部链接</button>
         <button id="exportTxtBtn">导出为 .txt</button>
     </div>
     <textarea id="urlsBox" readonly placeholder="这里会显示识别到的所有图片链接..."></textarea>
 </div>
</div>

<div id="cropModal">
  <div id="cropContainer">
    <div id="cropImageContainer">
      <img id="cropImage" src="" alt="Cropping Target">
    </div>
    <div class="crop-controls">
      <div class="row">
        <button class="aspect-btn" data-ratio="free">自由</button>
        <button class="aspect-btn" data-ratio="1.777">16:9</button>
        <button class="aspect-btn" data-ratio="1.333">4:3</button>
        <button class="aspect-btn" data-ratio="1">1:1</button>
      </div>
      <div class="row">
          <span>输出分辨率:</span>
          <input type="number" id="cropWidth" placeholder="宽">
          <span>x</span>
          <input type="number" id="cropHeight" placeholder="高">
      </div>
      <div class="row">
          <button id="cropDownloadBtn">裁剪并下载</button>
          <button id="cropCancelBtn" style="background-color: #6c757d;">取消</button>
      </div>
    </div>
  </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
<script>
 const API_BASE = "https://api.steamcmd.net/v1/info/";
 const STORE_API_BASE = "https://store.steampowered.com/api/appdetails?appids=";
 const IMG_BASE = "https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/";
 const snapThreshold = 10;
 
 // DOM Elements
 const appIdInput = document.getElementById("appId");
 const canvas = document.getElementById("heroCanvas");
 const ctx = canvas.getContext("2d");
 const errorBox = document.getElementById("error");
 const loadingBox = document.getElementById("loading");
 const scaleSlider = document.getElementById("scaleSlider");
 const scalePercent = document.getElementById("scalePercent");
 const saveBtn = document.getElementById("saveBtn");
 const goToStoreBtn = document.getElementById("goToStoreBtn");
 const overlaySlider = document.getElementById("overlaySlider");
 const overlayPercent = document.getElementById("overlayPercent");
 const imageInspector = document.getElementById("imageInspector");
 const imageList = document.getElementById("imageList");
 const urlsBox = document.getElementById("urlsBox");
 const gradientColorInput = document.getElementById("gradientColor");
 const gradientDirectionSelect = document.getElementById("gradientDirection");
 const toggleApiBtn = document.getElementById("toggleApiBtn");
 const apiViewerContainer = document.getElementById("apiViewerContainer");
 const apiTable = document.getElementById("api-table");
 const cropModal = document.getElementById('cropModal');
 const cropImage = document.getElementById('cropImage');
 const cropWidthInput = document.getElementById('cropWidth');
 const cropHeightInput = document.getElementById('cropHeight');
 
 // Global state variables
 let heroImg = new Image();
 let logoImg = new Image();
 let logoX = 0, logoY = 0, logoScale = 1;
 let customText = "", textColor = "#ffffff", textSize = 24, textFont = "微软雅黑";
 let textX = 20, textY = 20, lineSpacing = 5;
 let overlayOpacity = 0.4;
 let gradientColor = "#000000";
 let gradientDirection = "top-to-bottom";
 let dragging = false;
 let dragTarget = null;
 let dragOffsetX = 0, dragOffsetY = 0;
 let cropper = null;
 let imageCategories = {};
 let videoData = [];
 let screenshotUrls = [];

 function clearError() { errorBox.textContent = ""; }
 function showError(msg) { errorBox.textContent = msg; }
 function setLoading(msg) { loadingBox.textContent = msg; }
 function clearLoading() { loadingBox.textContent = ""; }
 function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

 function drawHero(img) { const cw = canvas.width, ch = canvas.height; ctx.clearRect(0, 0, cw, ch); if (!img.src) return; const scale = Math.max(cw / img.width, ch / img.height); const w = img.width * scale, h = img.height * scale; ctx.drawImage(img, (cw - w) / 2, (ch - h) / 2, w, h); if (overlayOpacity > 0) { let x0 = 0, y0 = 0, x1 = 0, y1 = 0; switch (gradientDirection) { case 'top-to-bottom': y1 = ch; break; case 'bottom-to-top': y0 = ch; break; case 'left-to-right': x1 = cw; break; case 'right-to-left': x0 = cw; break; case 'tl-to-br': x1 = cw; y1 = ch; break; case 'tr-to-bl': x0 = cw; y1 = ch; break; case 'bl-to-tr': y0 = ch; x1 = cw; break; case 'br-to-tl': x0 = cw; y0 = ch; break; } const g = ctx.createLinearGradient(x0, y0, x1, y1); g.addColorStop(0, hexToRgba(gradientColor, overlayOpacity)); g.addColorStop(1, hexToRgba(gradientColor, 0)); ctx.fillStyle = g; ctx.fillRect(0, 0, cw, ch); } }
 function drawLogo() { if (!logoImg.src || !logoImg.complete) return; ctx.drawImage(logoImg, logoX, logoY, logoImg.width * logoScale, logoImg.height * logoScale); }
 function drawText() { if (!customText) return; ctx.font = `${textSize}px "${textFont}"`; ctx.fillStyle = textColor; ctx.textBaseline = "top"; const lines = customText.split("\n"); lines.forEach((line, i) => { ctx.fillText(line, textX, textY + i * (textSize + lineSpacing)); }); }
 function drawAll() { drawHero(heroImg); drawLogo(); drawText(); }
 function snapToCenterX(objX, objW) { const centerX = (canvas.width - objW) / 2; return Math.abs(objX - centerX) < snapThreshold ? centerX : objX; }
 function snapToCenterY(objY, objH) { const centerY = (canvas.height - objH) / 2; return Math.abs(objY - centerY) < snapThreshold ? centerY : objY; }

 canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale;
    ctx.font = `${textSize}px "${textFont}"`;
    const lines = customText.split("\n");
    const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0;
    const textH = lines.length * (textSize + lineSpacing) - lineSpacing;

    if (e.ctrlKey) {
        dragTarget = "text";
        dragOffsetX = mx - textX;
        dragOffsetY = my - textY;
    } else if (e.shiftKey) {
        dragTarget = "both";
        dragOffsetX = mx - logoX;
        dragOffsetY = my - logoY;
    } else if (logoImg.src && mx >= logoX && mx <= logoX + logoW && my >= logoY && my <= logoY + logoH) {
        dragTarget = "logo";
        dragOffsetX = mx - logoX;
        dragOffsetY = my - logoY;
    } else if (customText && mx >= textX && mx <= textX + textW && my >= textY && my <= textY + textH) {
        dragTarget = "text";
        dragOffsetX = mx - textX;
        dragOffsetY = my - textY;
    }
    
    if (dragTarget) {
        dragging = true;
        canvas.style.cursor = "grabbing";
    }
 });
 canvas.addEventListener("mousemove", (e) => { if (!dragging) return; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale; ctx.font = `${textSize}px "${textFont}"`; const lines = customText.split("\n"); const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0; const textH = lines.length * (textSize + lineSpacing) - lineSpacing; if (dragTarget === "logo" || dragTarget === "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(logoImg.src) { newX = snapToCenterX(newX, logoW); newY = snapToCenterY(newY, logoH); } if (dragTarget === "logo") { logoX = newX; logoY = newY; } else { let offsetX = newX - logoX, offsetY = newY - logoY; logoX = newX; logoY = newY; textX += offsetX; textY += offsetY; } } if (dragTarget === "text" && dragTarget !== "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(customText) { newX = snapToCenterX(newX, textW); newY = snapToCenterY(newY, textH); } textX = newX; textY = newY; } drawAll(); });
 ["mouseup","mouseleave"].forEach(evt => { canvas.addEventListener(evt, () => { dragging = false; dragTarget = null; canvas.style.cursor = "grab"; }); });
 scaleSlider.addEventListener("input", (e) => { logoScale = e.target.value / 100; scalePercent.textContent = `${e.target.value}%`; drawAll(); });
 overlaySlider.addEventListener("input", (e) => { overlayOpacity = e.target.value / 100; overlayPercent.textContent = `${e.target.value}%`; drawAll(); });
 gradientColorInput.addEventListener("input", (e) => { gradientColor = e.target.value; drawAll(); });
 gradientDirectionSelect.addEventListener("change", (e) => { gradientDirection = e.target.value; drawAll(); });
 saveBtn.addEventListener("click", () => { const link = document.createElement("a"); link.download = `steam_${appIdInput.value.trim()}.png`; link.href = canvas.toDataURL("image/png"); link.click(); });
 goToStoreBtn.addEventListener('click', () => { const appId = appIdInput.value.trim(); if (appId) { const storeUrl = `https://store.steampowered.com/app/${appId}/`; window.open(storeUrl, '_blank'); }});
 document.getElementById("customText").addEventListener("input", (e) => { customText = e.target.value; drawAll(); });
 document.getElementById("textColor").addEventListener("input", (e) => { textColor = e.target.value; drawAll(); });
 document.getElementById("textSize").addEventListener("input", (e) => { textSize = parseInt(e.target.value, 10) || 24; drawAll(); });
 document.getElementById("textFont").addEventListener("change", (e) => { textFont = e.target.value; drawAll(); });
 document.getElementById("lineSpacing").addEventListener("input", (e) => { lineSpacing = parseInt(e.target.value, 10) || 0; drawAll(); });
 const tutorialPanel = document.getElementById('tutorial');
 document.getElementById('hideTutorialBtn').addEventListener('click', () => tutorialPanel.classList.add('hidden'));
 document.getElementById('showTutorialBtn').addEventListener('click', () => tutorialPanel.classList.remove('hidden'));
 
 function findImageCandidates(obj) { const results = new Set(); const imageRE = /\.(jpe?g|png|webp|gif)(\?|$)/i; function rec(v) { if (v == null) return; if (typeof v === 'string') { if (imageRE.test(v)) { results.add(v); } } else if (Array.isArray(v)) { for (const e of v) rec(e); } else if (typeof v === 'object') { for (const k in v) rec(v[k]); } } rec(obj); return [...results].map(s => s.split('#')[0].trim()).filter(Boolean); }
 
 function buildFullUrl(appid, candidate) {
     const trimmed = candidate.trim();
     if (/^https?:\/\//i.test(trimmed)) return trimmed;
     const clean = trimmed.replace(/^(\.\/|\/+)/, '');
     return `${IMG_BASE}${encodeURIComponent(appid)}/${clean}`;
 }

 function showAssets(urls, videos) {
     imageList.innerHTML = ''; 
     if (urls.length === 0 && videos.length === 0) { 
         imageList.innerHTML = '<p>没有识别到任何图片或视频资源。</p>'; 
         return; 
     } 
     imageList.innerHTML = `<p style="color: #60a5fa; text-align: center;">正在获取 ${urls.length} 张图片尺寸用于分组，请稍候...</p>`; 
     imageCategories = {}; 
     const promises = urls.map(u => new Promise(resolve => { 
         const img = new Image(); 
         img.src = u; 
         img.onload = () => resolve({ u, res: `${img.naturalWidth}x${img.naturalHeight}` }); 
         img.onerror = () => resolve({ u, res: '未知尺寸' }); 
     })); 
     Promise.all(promises).then(results => { 
         results.forEach(({ u, res }) => { 
             if (!imageCategories[res]) imageCategories[res] = []; 
             imageCategories[res].push(u); 
         }); 
         renderCategories(imageCategories, videos); 
     }); 
 }
 
 function createCategoryElement(title, items, isVideo = false) {
    const wrapper = document.createElement('div');
    wrapper.className = 'category';
    const header = document.createElement('div');
    header.className = 'category-header';
    header.innerHTML = `<h4>${title} (${items.length} ${isVideo ? '个' : '张'})</h4><button class="toggle-btn">展开</button>`;
    wrapper.appendChild(header);
    const cardGrid = document.createElement('div');
    cardGrid.className = 'card-grid';

    items.forEach(item => {
        const card = document.createElement('div');
        card.className = 'card';
        if (!isVideo) {
            const u = item;
            if (u.toLowerCase().includes('schinese')) {
                card.classList.add('highlight-schinese');
            }
            const langMatch = u.match(/(schinese|tchinese|english|japanese|koreana|french|german|spanish|latam)/i);
            const lang = langMatch ? langMatch[0] : '通用';
            card.innerHTML = `<img src="${u}" alt="image" class="thumb" loading="lazy" onclick="this.style.objectFit = this.style.objectFit === 'contain' ? 'cover' : 'contain'"><div class="meta">${lang}</div><div class="actions"><button data-url="${u}" class="open-btn">打开</button><button data-url="${u}" class="copy-btn">复制</button><button data-url="${u}" class="crop-btn">裁剪</button><button data-url="${u}" class="dl-btn">下载</button></div>`;
        } else { // Video card
            const video = item;
            card.innerHTML = `
                <img src="${video.thumbnail}" alt="${video.name}" class="thumb" loading="lazy">
                <div class="meta" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${video.name}">${video.name}</div>
                <div class="actions">
                    <button data-url="${video.thumbnail}" class="open-btn">封面</button>
                    <button data-url="${video.thumbnail}" class="dl-btn">下封面</button>
                    <button data-url="${video.mp4.max}" class="open-btn" style="background-color:#e11d48;">播放</button>
                    <button data-url="${video.mp4.max}" class="dl-btn" style="background-color:#e11d48;">下视频</button>
                </div>`;
        }
        cardGrid.appendChild(card);
    });

    wrapper.appendChild(cardGrid);
    const toggleBtn = header.querySelector('.toggle-btn');
    toggleBtn.onclick = () => {
        const isHidden = cardGrid.style.display === 'none';
        cardGrid.style.display = isHidden ? 'grid' : 'none';
        toggleBtn.textContent = isHidden ? '折叠' : '展开';
    };
    return wrapper;
 }

 function renderCategories(categories, videos) {
     imageList.innerHTML = '';
     
     if (categories['1920x1080']) {
         const screenshotElement = createCategoryElement('截图', categories['1920x1080']);
         imageList.appendChild(screenshotElement);
         delete categories['1920x1080'];
     }
     
     if (videos && videos.length > 0) {
        const videoElement = createCategoryElement('宣传影像', videos, true);
        imageList.appendChild(videoElement);
     }

     const sortedKeys = Object.keys(categories).sort((a, b) => { 
         if (a === '未知尺寸') return 1; 
         if (b === '未知尺寸') return -1; 
         const [wA, hA] = a.split('x').map(Number); 
         const [wB, hB] = b.split('x').map(Number); 
         return (wB * hB) - (wA * hA);
     }); 
     sortedKeys.forEach(res => { 
         const urls = categories[res]; 
         const categoryElement = createCategoryElement(`分辨率: ${res}`, urls);
         imageList.appendChild(categoryElement);
     }); 
 }

 imageList.addEventListener('click', e => { const target = e.target; const url = target.dataset.url; if (!url) return; if (target.classList.contains('open-btn')) { window.open(url, '_blank'); } else if (target.classList.contains('copy-btn')) { navigator.clipboard.writeText(url).then(() => { setLoading('链接已复制!'); setTimeout(clearLoading, 1500); }); } else if (target.classList.contains('dl-btn')) { downloadImage(url); } else if (target.classList.contains('crop-btn')) { cropImage.src = url; cropModal.style.display = 'flex'; cropImage.onload = () => { if(cropper) { cropper.destroy(); } cropper = new Cropper(cropImage, { viewMode: 1, background: false, autoCropArea: 0.9 }); }; } });
 document.getElementById('copyAllBtn').addEventListener('click', () => { if (!urlsBox.value) return; navigator.clipboard.writeText(urlsBox.value).then(() => { setLoading('全部链接已复制!'); setTimeout(clearLoading, 1500); }); });
 document.getElementById('exportTxtBtn').addEventListener('click', () => { if (!urlsBox.value) return; const blob = new Blob([urlsBox.value], {type:'text/plain;charset=utf-8'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `steam_${appIdInput.value.trim()}_assets.txt`; a.click(); URL.revokeObjectURL(a.href); });
 document.getElementById('cropDownloadBtn').addEventListener('click', () => { if (!cropper) return; const cropWidth = parseInt(cropWidthInput.value, 10); const cropHeight = parseInt(cropHeightInput.value, 10); const options = {}; if (!isNaN(cropWidth) && cropWidth > 0) options.width = cropWidth; if (!isNaN(cropHeight) && cropHeight > 0) options.height = cropHeight; const canvas = cropper.getCroppedCanvas(options); const link = document.createElement('a'); link.download = `cropped_${appIdInput.value.trim()}_${Date.now()}.png`; link.href = canvas.toDataURL('image/png'); link.click(); document.getElementById('cropCancelBtn').click(); });
 document.getElementById('cropCancelBtn').addEventListener('click', () => { cropModal.style.display = 'none'; if (cropper) { cropper.destroy(); cropper = null; } cropImage.src = ''; cropWidthInput.value = ''; cropHeightInput.value = ''; });
 document.querySelectorAll('.aspect-btn').forEach(btn => { btn.addEventListener('click', (e) => { if (!cropper) return; const ratio = e.target.dataset.ratio; cropper.setAspectRatio(ratio === 'free' ? NaN : parseFloat(ratio)); cropWidthInput.value = ''; cropHeightInput.value = ''; }); });
 
 function updateCropAspectRatio() { if (!cropper) return; const width = parseFloat(cropWidthInput.value); const height = parseFloat(cropHeightInput.value); if (width > 0 && height > 0) { cropper.setAspectRatio(width / height); } else { cropper.setAspectRatio(NaN); } }
 cropWidthInput.addEventListener('input', updateCropAspectRatio);
 cropHeightInput.addEventListener('input', updateCropAspectRatio);

function buildApiTable(appData, storeData) {
    const data = appData.data || {};
    const common = appData.common || {};
    let html = '';

    const get = (obj, path, defaultValue = '') => {
        const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
        return value !== undefined && value !== null ? value : defaultValue;
    };

    const addRow = (label, value) => {
        if (value === '' || value === undefined || value === null || (Array.isArray(value) && value.length === 0)) return;
        html += `<tr><td>${label}</td><td>${value}</td></tr>`;
    };

    const addSection = (title) => {
        html += `<tr><td colspan="2" class="api-section-header">${title}</td></tr>`;
    };
    
    const formatTimestamp = (ts) => {
        if (!ts || isNaN(ts)) return 'N/A';
        const date = new Date(ts * 1000);
        return date.toUTCString();
    };
    
    const englishName = get(common, 'name', '基本信息');
    const chineseName = get(common, 'name_localized.schinese');
    let titleHtml = `<p class="api-game-title">${englishName}</p>`;
    if (chineseName) {
        titleHtml += `<p class="api-game-title-zh">${chineseName}</p>`;
    }
    html += `<tr class="api-title-header"><td colspan="2">${titleHtml}</td></tr>`;
    
    if (storeData) {
        if(storeData.about_the_game) addRow('关于游戏', storeData.about_the_game);
        if(storeData.short_description) addRow('简介', storeData.short_description);
        if(storeData.website) addRow('主页', `<a href="${storeData.website}" target="_blank">${storeData.website}</a>`);
    }

    addRow('APP ID', get(data, 'steam_appid'));
    addRow('APP 类型', get(common, 'type'));
    addRow('开发商', get(data, 'developers', []).join(', '));
    addRow('发行商', get(data, 'publishers', []).join(', '));
    
     if (storeData) {
        if(storeData.genres) addRow('分类', storeData.genres.map(g => g.description).join(', '));
        if(storeData.categories) addRow('标签', storeData.categories.map(c => c.description).join(', '));
    }

    addRow('Last Changenumber', get(common, 'last_changenumber'));
    addRow('最后更新时间', formatTimestamp(get(common, 'last_record_update')));
    addRow('发售时间', get(data, 'release_date.coming_soon') ? 'To be announced' : formatTimestamp(get(data, 'release_date.date')));
    addRow('控制器支持', get(data, 'controller_support'));
    addRow('发布状态', get(common, 'releasestate'));
    if (get(common, 'exfgls')) addRow('禁用家庭共享(exfgls)', get(common, 'exfgls'));
    addRow('商店页发行日期', formatTimestamp(get(common, 'steam_release_date')));
    
    if (storeData && storeData.pc_requirements && Object.keys(storeData.pc_requirements).length > 0) {
        addSection('PC 配置要求');
        if(storeData.pc_requirements.minimum) addRow('最低配置', storeData.pc_requirements.minimum);
        if(storeData.pc_requirements.recommended) addRow('推荐配置', storeData.pc_requirements.recommended);
    }
    
    const localized = get(common, 'name_localized');
    if (localized && Object.keys(localized).length > 0) {
        addSection('本地化名称');
        const langMap = {'english':'英语','japanese':'日语','schinese':'简体中文','tchinese':'繁体中文','french':'法语','german':'德语','italian':'意大利语','koreana':'韩语','spanish':'西班牙语','russian':'俄语','thai':'泰语','portuguese':'葡萄牙语','polish':'波兰语','danish':'丹麦语','dutch':'荷兰语','finnish':'芬兰语','norwegian':'挪威语','swedish':'瑞典语','hungarian':'匈牙利语','czech':'捷克语','romanian':'罗马尼亚语','turkish':'土耳其语','arabic':'阿拉伯语','bulgarian':'保加利亚语','greek':'希腊语','ukrainian':'乌克兰语','vietnamese':'越南语','brazilian':'巴西葡萄牙语','latam':'拉丁美洲西班牙语'};
        Object.entries(localized).forEach(([lang, name]) => addRow(langMap[lang] || lang, name));
    }
    
    const langValue = get(data, 'supported_languages');
    if (langValue) {
        addSection("支持的语言");
        const langMap = {'english': '英语', 'japanese': '日语', 'french': '法语', 'italian': '意大利语', 'german': '德语', 'spanish': '西班牙语 - 西班牙', 'brazilian': '葡萄牙语 - 巴西', 'russian': '俄语', 'schinese': '简体中文', 'tchinese': '繁体中文', 'koreana': '韩语'};
        let langTable = '<table class="language-table"><thead><tr><th>语言</th><th>界面</th><th>音频</th><th>字幕</th></tr></thead><tbody>';
        Object.entries(langValue).forEach(([lang, support]) => {
            if (support.supported) {
                langTable += `<tr><td>${langMap[lang] || lang}</td><td class="support-cell"><span class="check-mark">✔</span></td><td class="support-cell">${support.full_audio ? '<span class="check-mark">✔</span>' : ''}</td><td class="support-cell">${support.subtitles ? '<span class="check-mark">✔</span>' : ''}</td></tr>`;
            }
        });
        langTable += '</tbody></table>';
        html += `<tr><td colspan="2">${langTable}</td></tr>`;
    }

    if (storeData && storeData.movies && storeData.movies.length > 0) {
        addSection('宣传影像');
        storeData.movies.forEach(movie => {
            if (movie.mp4 && movie.mp4.max) {
                 addRow(movie.name, `<a href="${movie.mp4.max}" target="_blank">${movie.mp4.max}</a>`);
            }
        });
    }

    apiTable.innerHTML = html;
}
 
 async function fetchData(appId) {
    clearError(); setLoading("正在请求API...");
    saveBtn.disabled = true; goToStoreBtn.disabled = true; scaleSlider.disabled = true; 
    toggleApiBtn.style.display = 'none'; apiViewerContainer.style.display = 'none';
    imageInspector.style.display = 'none'; imageList.innerHTML = ''; urlsBox.value = '';
    screenshotUrls = [];
    videoData = [];

    try {
        const proxyUrl = 'https://corsproxy.io/?';
        const storeApiUrl = `${STORE_API_BASE}${appId}&l=schinese`;
        
        const [steamCmdRes, storeRes] = await Promise.all([
            fetch(API_BASE + appId),
            fetch(proxyUrl + encodeURIComponent(storeApiUrl))
        ]);

        if (!steamCmdRes.ok) throw new Error(`SteamCMD API 请求失败: ${steamCmdRes.status}`);
        
        const steamCmdJson = await steamCmdRes.json();
        const appData = steamCmdJson.data?.[appId];
        if (!appData) {
            throw new Error(steamCmdJson.message || "未找到游戏数据或API返回格式无效");
        }
        
        let storeData = null;
        if (storeRes.ok) {
            const storeJson = await storeRes.json();
            const storeResult = storeJson[appId];
            if (storeResult?.success) {
                storeData = storeResult.data;
            }
        } else {
             console.warn(`商店 API 请求失败: ${storeRes.status}`);
        }
        
        buildApiTable(appData, storeData);
        toggleApiBtn.style.display = 'block';
        
        setLoading("正在加载拼图资源...");
        
        let gameName = appData.common?.name_localized?.schinese || appData.common?.metacritic_name || appData.common?.name || "";
        customText = `3DM《${gameName}》专区`;
        document.getElementById("customText").value = customText;
        
        const assetsFull = appData.common?.library_assets_full;
        if (!assetsFull) throw new Error("缺少 library_assets_full 数据");
        
        const heroPath = assetsFull.library_hero?.image?.english;
        let logoPath = assetsFull.library_logo?.image?.schinese || assetsFull.library_logo?.image?.english;
        if (!heroPath) throw new Error("未找到 library_hero 图片");
        
        const heroUrl = IMG_BASE + appId + "/" + heroPath;
        let logoUrl = logoPath ? IMG_BASE + appId + "/" + logoPath : `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`;
        
        heroImg = new Image(); heroImg.crossOrigin = "anonymous"; heroImg.src = heroUrl;
        logoImg = new Image(); logoImg.crossOrigin = "anonymous"; logoImg.src = logoUrl;
        
        await Promise.all([
            new Promise((res, rej) => { heroImg.onload = res; heroImg.onerror = () => rej(new Error('背景图加载失败')); }),
            new Promise((res) => { logoImg.onload = res; logoImg.onerror = () => { logoImg.src = `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`; logoImg.onload = res; logoImg.onerror = res; }; }),
        ]);
        
        drawHero(heroImg);
        if(logoImg.complete && logoImg.naturalWidth > 0) {
           logoScale = (0.2 * canvas.width) / logoImg.width;
           const logoW = logoImg.width * logoScale;
           const logoH = logoImg.height * logoScale;
           logoX = (canvas.width - logoW) / 2;
           logoY = (canvas.height - logoH) / 2;
           
           scaleSlider.value = Math.round(logoScale * 100);
           scalePercent.textContent = `${Math.round(logoScale * 100)}%`;
           scaleSlider.disabled = false;
        } else { 
           logoImg.src = ''; 
           scaleSlider.disabled = true; 
        }

        saveBtn.disabled = false;
        goToStoreBtn.disabled = false;

        ctx.font = `${textSize}px "${textFont}"`;
        const lines = customText.split("\n");
        const textW = Math.max(...lines.map(line => ctx.measureText(line).width));
        const textH = lines.length * (textSize + lineSpacing) - lineSpacing;
        textX = (canvas.width - textW) / 2;
        textY = (canvas.height - textH) / 2 + 30;
        drawAll();

        setLoading("正在解析图片与视频资源...");
        let candidates = findImageCandidates(steamCmdJson);
        let allImageUrls = [...new Set(candidates.map(c => buildFullUrl(appId, c)))];
        let allAssetUrlsForTxt = [...allImageUrls];

        if (storeData?.screenshots) {
            screenshotUrls = storeData.screenshots.map(ss => ss.path_full);
            allImageUrls.push(...screenshotUrls);
            allImageUrls = [...new Set(allImageUrls)];
            allAssetUrlsForTxt.push(...screenshotUrls);
        }
        
        if (storeData?.movies) {
            videoData = storeData.movies.filter(m => m.mp4 && m.mp4.max);
            videoData.forEach(v => {
                allAssetUrlsForTxt.push(v.thumbnail);
                allAssetUrlsForTxt.push(v.mp4.max);
            });
        }

        imageInspector.style.display = 'block';
        if (allImageUrls.length > 0 || videoData.length > 0) {
            urlsBox.value = [...new Set(allAssetUrlsForTxt)].join('\n');
            showAssets(allImageUrls, videoData);
        } else {
            imageList.innerHTML = '<p>未能自动识别到任何图片或视频资源。</p>';
        }
        clearLoading();
    } catch (e) {
        showError(e.message || "未知错误");
        clearLoading();
    }
}
 
 function downloadImage(url, filename) {
     setLoading('正在准备下载...');
     fetch(url)
        .then(response => response.blob())
        .then(blob => {
            saveAs(blob, filename || url.split('/').pop().split('?')[0] || `asset.tmp`);
            clearLoading();
        })
        .catch(err => {
            showError(`下载失败: ${err.message}. 正在尝试直接打开...`);
            clearLoading();
            window.open(url, '_blank');
        });
 }

 async function performCropAndGetBlob(sourceUrl, targetWidth, targetHeight) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const proxyUrl = 'https://corsproxy.io/?';
        img.src = proxyUrl + encodeURIComponent(sourceUrl);
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');
            
            const sourceAspect = img.width / img.height;
            const targetAspect = targetWidth / targetHeight;
            let sx, sy, sWidth, sHeight;

            if (sourceAspect > targetAspect) {
                sHeight = img.height;
                sWidth = sHeight * targetAspect;
                sx = (img.width - sWidth) / 2;
                sy = 0;
            } else {
                sWidth = img.width;
                sHeight = sWidth / targetAspect;
                sx = 0;
                sy = (img.height - sHeight) / 2;
            }
            
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);
            
            canvas.toBlob(blob => {
                if (blob) {
                    resolve(blob);
                } else {
                    reject(new Error('Canvas toBlob failed'));
                }
            }, 'image/png');
        };
        img.onerror = () => reject(new Error(`图片加载失败: ${sourceUrl}`));
    });
 }
 
 async function autoCropAndZip() {
    const appId = appIdInput.value.trim();
    if (!appId) return;
    const zip = new JSZip();
    
    const findImage = (resolution) => {
        const urls = imageCategories[resolution] || [];
        return urls.find(u => u.includes('schinese')) || urls[0] || null;
    };

    const source920 = findImage('920x430');
    const source300 = findImage('300x450');
    
    let tasks = [];

    if (source300) {
        tasks.push(async () => {
            try {
                setLoading("正在获取 300x450 图...");
                const response = await fetch(source300);
                if (!response.ok) throw new Error('Network response was not ok.');
                const blob = await response.blob();
                zip.file(`${appId}_300x450.png`, blob);
            } catch (e) {
                showError(`获取 300x450 图失败: ${e.message}`);
            }
        });
    } else {
        showError("未找到 300x450 图片。");
    }

    if (source920) {
        const cropTargets = [ { w: 474, h: 242 }, { w: 497, h: 278 }, { w: 300, h: 180 } ];
        cropTargets.forEach(target => {
            tasks.push(async () => {
                try {
                    setLoading(`正在裁剪 ${target.w}x${target.h} 图...`);
                    const blob = await performCropAndGetBlob(source920, target.w, target.h);
                    zip.file(`${appId}_${target.w}x${target.h}.png`, blob);
                } catch (e) {
                    showError(`裁剪 ${target.w}x${target.h} 失败: ${e.message}`);
                }
            });
        });
    } else {
        showError("未找到 920x430 图片用于裁剪。");
    }

    if (tasks.length === 0) {
        clearLoading();
        showError("未找到任何符合条件的图片。");
        return;
    }

    for (const task of tasks) {
        await task();
    }

    if (Object.keys(zip.files).length === 0) {
        clearLoading();
        showError("所有图片处理均失败，无法创建 ZIP。");
        return;
    }
    
    setLoading('正在生成 ZIP 文件...');
    try {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${appId}_covers.zip`);
        setLoading('打包下载已开始！');
    } catch (e) {
        showError(`生成 ZIP 失败: ${e.message}`);
    } finally {
        setTimeout(clearLoading, 2000);
    }
 }

 async function downloadAssetsAsZip(assets, zipFilename) {
    const zip = new JSZip();
    let fetchedCount = 0;
    
    const assetPromises = assets.map(async (asset) => {
        try {
            const response = await fetch(asset.url);
            if (!response.ok) throw new Error(`Failed to fetch ${asset.filename}`);
            const blob = await response.blob();
            fetchedCount++;
            setLoading(`正在获取资源 (${fetchedCount}/${assets.length})...`);
            return { filename: asset.filename, blob: blob };
        } catch (e) {
            console.error(e);
            showError(`获取 ${asset.filename} 失败`);
            return null;
        }
    });

    const fetchedAssets = (await Promise.all(assetPromises)).filter(Boolean);

    if (fetchedAssets.length === 0) {
        showError("所有资源获取失败，无法创建 ZIP 文件。");
        clearLoading();
        return;
    }

    fetchedAssets.forEach(asset => zip.file(asset.filename, asset.blob));

    setLoading('正在生成 ZIP 文件，请稍候...');
    try {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, zipFilename);
        setLoading('ZIP 文件已开始下载！');
    } catch (e) {
        showError(`生成 ZIP 文件失败: ${e.message}`);
    } finally {
        setTimeout(clearLoading, 2000);
    }
}

 async function downloadAllScreenshots() {
    if (screenshotUrls.length === 0) {
        showError("没有可下载的截图。");
        return;
    }
    const appId = appIdInput.value.trim();
    if (!appId) return;
    const assetsToZip = screenshotUrls.map((url, i) => ({
        url: url,
        filename: `${appId}_screenshot_${i + 1}.jpg`
    }));
    await downloadAssetsAsZip(assetsToZip, `${appId}_screenshots.zip`);
 }

 document.getElementById("fetchBtn").addEventListener("click", () => {
     const rawInput = appIdInput.value.trim();
     let appId = rawInput;
     
     const urlMatch = rawInput.match(/store\.steampowered\.com\/app\/(\d+)/);
     if (urlMatch && urlMatch[1]) {
         appId = urlMatch[1];
         appIdInput.value = appId;
     }

     if (!/^\d+$/.test(appId)) { 
        showError("请输入有效的 Steam App ID 或商店链接"); 
        return; 
     }
     fetchData(appId);
 });
 
 toggleApiBtn.addEventListener('click', () => {
     const isHidden = apiViewerContainer.style.display === 'none';
     apiViewerContainer.style.display = isHidden ? 'block' : 'none';
     toggleApiBtn.textContent = isHidden ? '隐藏 API 数据' : '查看 API 数据';
 });
 
 document.getElementById("autoCropBtn").addEventListener('click', autoCropAndZip);
 document.getElementById("downloadScreenshotsBtn").addEventListener('click', downloadAllScreenshots);
 
 window.addEventListener('DOMContentLoaded', () => {
     const params = new URLSearchParams(window.location.search);
     const appIdFromUrl = params.get("appid");
     if (appIdFromUrl) {
         appIdInput.value = appIdFromUrl;
         fetchData(appIdFromUrl);
     }
 });

</script>
</body>
</html>
