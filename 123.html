<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>æ«å°ç—•è‡ªå·±çš„steamdb</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.css" />
<style>
 @import url('https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap');
 /* ... CSS ... */
 * { box-sizing: border-box; }
 body {
 background: #121417; color: #e0e0e0; font-family: 'Roboto Slab', "å¾®è½¯é›…é»‘", sans-serif;
 display: flex; flex-direction: column; align-items: center;
 padding: 25px 15px 40px; min-height: 100vh;
 }
 .main-container, #imageInspector, #apiViewerContainer {
 width: 100%; max-width: 1200px;
 }
 .header-container {
 display: flex; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 1200px;
 }
 h1 {
 margin: 0; font-weight: 700; font-size: 2.4rem; letter-spacing: 2px;
 color: #60a5fa; text-shadow: 0 0 10px #60a5faaa;
 }
 .header-controls {
    margin-left: auto; display: flex; align-items: center; gap: 20px;
 }
 .controls {
 display: flex; gap: 12px; margin-bottom: 15px;
 width: 100%; max-width: 820px; flex-wrap: wrap; align-items: center;
 }
 input, button, select, textarea {
 border-radius: 8px; border: none; font-size: 14px;
 outline: none; transition: all 0.25s ease; font-weight: 500;
 }
 input[type="text"], input[type="number"], select, textarea {
 background: #23262a; color: #ddd; padding: 8px 12px;
 box-shadow: inset 0 0 6px #0008;
 }
 input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
 background: #2b2e34; box-shadow: inset 0 0 8px #60a5faaa; color: #eef3ff;
 }
 #appId {
 height: 36px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 button {
 background: #3b82f6; color: white; cursor: pointer; padding: 10px 22px;
 font-weight: 700; box-shadow: 0 4px 15px #3b82f6bb; flex: none;
 }
 button:disabled { background: #606c8f; cursor: not-allowed; box-shadow: none; }
 button:hover:not(:disabled) { background: #2563eb; box-shadow: 0 6px 20px #2563ebcc; }
 #customText {
 resize: vertical; min-height: 60px; max-height: 120px;
 padding: 8px 12px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 input[type="color"] {
 min-width: 48px; height: 36px; padding: 2px; cursor: pointer; flex: none;
 border-radius: 8px; border: 2px solid transparent; transition: border-color 0.2s ease;
 background: #23262a;
 }
 input[type="color"]:focus { border-color: #60a5fa; }
 input[type="number"] { width: 80px; height: 36px; text-align: center; flex: none; }
 select { width: 150px; cursor: pointer; height: 36px; flex: none; }
 #canvas-container {
 background: #171c29; width: 100%; max-width: 1200px; height: 278px;
 position: relative; overflow: visible; box-shadow: 0 0 25px #2563eb44 inset;
 border-radius: 12px; cursor: grab; margin: 0 auto;
 }
 canvas { display: block; user-select: none; border-radius: 12px; }
 .slider-container, .main-container .controls {
 margin-left: auto; margin-right: auto;
 }
 .slider-container {
 margin-top: 15px; width: 100%; max-width: 600px; display: flex;
 align-items: center; gap: 15px; color: #bbb;
 }
 input[type="range"] {
 flex: 1; -webkit-appearance: none; height: 6px; border-radius: 6px;
 background: #4b6cb7; cursor: pointer; transition: background-color 0.2s ease;
 }
 input[type="range"]:hover { background: #3b82f6; }
 input[type="range"]::-webkit-slider-thumb {
 -webkit-appearance: none; width: 16px; height: 16px; background: #60a5fa;
 border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px #60a5faaa;
 transition: background-color 0.2s ease;
 }
 input[type="range"]:active::-webkit-slider-thumb { background: #2563eb; box-shadow: 0 0 12px #2563ebcc; }
 #scalePercent, #overlayPercent { min-width: 45px; font-weight: 600; color: #60a5fa; }
 .status-box { margin-top: 18px; min-height: 1.5em; text-align: center; font-weight: 700; width: 100%; max-width: 820px; }
 #error { color: #ef4444; }
 #loading { color: #60a5fa; }
 #tutorial {
 position: fixed; top: 20px; right: 20px; width: 380px; z-index: 1000;
 padding: 20px 25px; background: #1e2433ee; backdrop-filter: blur(8px);
 border-radius: 14px; font-size: 14px; line-height: 1.7; border: 1px solid #2e3a59;
 box-shadow: 0 8px 30px rgba(0,0,0,0.4); max-height: calc(100vh - 40px);
 overflow-y: auto; transition: opacity 0.3s ease, transform 0.3s ease;
 }
 #tutorial.hidden {
 opacity: 0; transform: translateX(20px); pointer-events: none;
 }
 .tutorial-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
 #tutorial h2 { margin: 0; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; font-size: 20px; }
 #tutorial h3 { margin: 20px 0 10px; color: #82b9ff; font-weight: 700; border-bottom: 1px solid #2e3a59; padding-bottom: 5px;}
 #tutorial ul { list-style-type: disc; padding-left: 20px; color: #ccc; margin: 0; }
 #tutorial ul li { margin-bottom: 10px; }
 #tutorial p { margin: 10px 0; }
 #tutorial code, #tutorial kbd { background: #121417; padding: 2px 5px; border-radius: 4px; font-family: monospace; color: #ffb86c; border: 1px solid #444; }
 .toggle-tutorial-btn {
 background: none; border: 1px solid #4b6cb7; color: #bbb;
 padding: 4px 10px; font-size: 12px; cursor: pointer; box-shadow: none;
 }
 #showTutorialBtn {
 font-size: 20px; padding: 0 10px; background: #23262a;
 border: 1px solid #2e3a59; box-shadow: none;
 }
 #imageInspector {
 text-align: left; margin-top: 36px; padding: 20px 25px; background: #1e2433;
 border-radius: 14px; font-size: 15px; line-height: 1.7;
 box-shadow: 0 0 20px #1e2433; border: 1px solid #2e3a59;
 }
 #imageInspector h3 { margin: 0 0 15px; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; }
 .inspector-controls { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
 #urlsBox { width: 100%; min-height: 120px; resize: vertical; margin-bottom: 15px; }
 .url-actions-container { margin-top: 25px; }
 .category { margin-bottom: 20px; padding: 15px; border-radius: 12px; background: rgba(0,0,0,0.2); border: 1px solid #2e3a59; }
 .category-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
 .category-header h4 { margin: 0; font-size: 16px; font-weight: bold; color: #fff; background: #60a5fa; display: inline-block; padding: 4px 10px; border-radius: 6px; }
 .toggle-btn { font-size: 12px; padding: 4px 10px; background: transparent; border: 1px solid #4b6cb7; color: #bbb; box-shadow: none; }
 .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px; }
 .card { background: #23262a; padding: 8px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 8px; align-items: center; transition: all 0.2s ease; border: 2px solid transparent; }
 .card:hover { transform: translateY(-4px); box-shadow: 0 6px 20px rgba(96,165,250,0.3); }
 .card.highlight-schinese {
 border-color: #60a5fa; box-shadow: 0 0 15px rgba(96, 165, 250, 0.6);
 }
 .thumb {
 width: 100%; height: 120px; object-fit: contain; border-radius: 8px;
 background: #121214; cursor: pointer;
 }
 .card .meta { width: 100%; font-size: 13px; color: #9aa4b2; text-align: center; }
 .card .actions { display: flex; gap: 8px; width: 100%; flex-wrap: wrap; justify-content: center; }
 .card .actions button { font-size: 12px; padding: 6px 10px; background: #4b6cb7; box-shadow: none; }
 .card .actions button:hover:not(:disabled) { background: #3b82f6; }
 
 /* --- NEW UI STYLES FOR API VIEWER --- */
 #apiViewerContainer {
    margin-top: 36px; background: #1e2433; border-radius: 14px;
    border: 1px solid #2e3a59; box-shadow: 0 0 20px #1e2433;
    padding: 0; overflow: hidden;
 }
 #apiViewerContainer h3 {
    margin: 0; font-weight: 700; color: #60a5fa;
    padding: 15px 25px; background-color: #2a3141;
    border-bottom: 1px solid #2e3a59;
    text-shadow: 0 0 10px #60a5faaa;
 }
 #api-table {
    width: 100%; border-collapse: collapse; font-size: 14px;
 }
 #api-table tr:nth-child(even):not(.api-section-header) td { background-color: rgba(0,0,0,0.15); }
 #api-table tr:hover:not(.api-section-header) td { background-color: rgba(96,165,250,0.1); }
 #api-table td {
    padding: 12px 15px; vertical-align: middle;
    border-bottom: 1px solid #2e3a59;
 }
 #api-table tr:last-child td { border-bottom: none; }
 #api-table td:nth-child(1) {
    font-weight: 700; color: #aeb9c7; width: 250px;
    text-align: right; word-break: break-word;
 }
 #api-table td:nth-child(2) { color: #e0e0e0; word-break: break-word; }
 #api-table td:nth-child(2) :is(ul, ol) { padding-left: 20px; margin: 0; }
 #api-table td:nth-child(2) img { max-width: 100%; border-radius: 6px; }
 .api-game-title { font-size: 20px; font-weight: bold; color: #ccc; margin: 5px 0 0 0; }
 .api-game-title-zh { font-size: 28px; font-weight: bold; color: #60a5fa; text-shadow: 0 0 10px #60a5faaa; margin: 0; }
 #api-table .api-section-header td {
    font-size: 16px; font-weight: bold; color: #e0e0e0;
    background-color: #3a4255; text-align: left;
    padding: 10px 15px !important;
    border-top: 1px solid #4a5568;
    border-bottom: 1px solid #4a5568;
 }
 #api-table .api-title-header td {
    border: none; padding: 20px 15px !important; text-align: left;
 }
 #api-table a { color: #60a5fa; text-decoration: none; }
 #api-table a:hover { text-decoration: underline; }
 #api-table code { background: #121417; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
 .api-tag {
    display: inline-block; background-color: #3b5a94; color: #e0e0e0;
    padding: 3px 8px; border-radius: 4px; font-size: 13px;
    margin: 2px; text-decoration: none; border: 1px solid #4b6cb7;
 }
 .api-tag:hover { background-color: #4b6cb7; }
 .language-table { width: 100%; margin-top: 5px; border: 1px solid #2e3a59; border-radius: 6px; border-collapse: separate; border-spacing: 0; }
 .language-table th, .language-table td { text-align: left; padding: 6px 8px; border-bottom: 1px solid #2e3a59; }
 .language-table tr:last-child td { border-bottom: none; }
 .language-table th { color: #aeb9c7; background: #23262a; }
 .language-table .support-cell { text-align: center; }
 .check-mark { color: #4ade80; font-weight: bold; }
 .platform-icon { display: inline-block; vertical-align: middle; margin: 0 4px; }
 /* --- END NEW UI STYLES --- */

 #cropModal {
     position: fixed; top: 0; left: 0; width: 100%; height: 100%;
     background: rgba(0, 0, 0, 0.8); z-index: 2000;
     display: none; align-items: center; justify-content: center;
     backdrop-filter: blur(5px);
 }
 #cropContainer {
     background: #1e2433; padding: 20px; border-radius: 14px;
     max-width: 90vw; max-height: 90vh; display: flex; flex-direction: column;
     box-shadow: 0 8px 30px rgba(0,0,0,0.4); border: 1px solid #2e3a59;
 }
 #cropImageContainer { max-width: 80vw; max-height: 70vh; }
 #cropImage { display: block; max-width: 100%; max-height: 100%; }
 .crop-controls { margin-top: 15px; text-align: center; display: flex; flex-direction: column; gap: 10px; justify-content: center;}
 .crop-controls .row { display: flex; gap: 10px; justify-content: center; align-items: center; }
 .crop-controls .row button, .crop-controls button { font-size: 12px; padding: 6px 12px;}
 .crop-controls input[type="number"] { width: 70px; height: 30px; }

</style>
</head>
<body>

<div id="tutorial" class="hidden">
    <div class="tutorial-header">
        <h2>ä½¿ç”¨è¯´æ˜</h2>
        <button id="hideTutorialBtn" class="toggle-tutorial-btn">å…³é—­</button>
    </div>
    <p>è¿™æ˜¯ä¸€ä¸ªä¸ºæ¸¸æˆç¼–è¾‘å’Œç¤¾åŒºè¿è¥äººå‘˜è®¾è®¡çš„åœ¨çº¿å·¥å…·ï¼Œæ—¨åœ¨å¿«é€Ÿè·å–å’Œå¤„ç† Steam æ¸¸æˆçš„å„ç±»å›¾ç‰‡ç´ æã€‚</p>

    <h3>âœ¨ ä¸»è¦åŠŸèƒ½</h3>
    <h4>è‡ªå®šä¹‰æ¨ªå¹…ç”Ÿæˆå™¨</h4>
    <ul>
        <li><strong>æ™ºèƒ½åŠ è½½</strong>ï¼šè‡ªåŠ¨åŠ è½½æ¸¸æˆçš„é«˜æ¸…èƒŒæ™¯å›¾ï¼Œå¹¶ä¼˜å…ˆåŠ è½½ç®€ä½“ä¸­æ–‡ç‰ˆ (<code>schinese</code>) çš„ Logoã€‚</li>
        <li><strong>é»˜è®¤å±…ä¸­</strong>ï¼šLogo é»˜è®¤æ”¾ç½®åœ¨ç”»å¸ƒæ­£ä¸­å¤®ï¼Œæ–¹ä¾¿æ‹–åŠ¨è°ƒæ•´ã€‚</li>
        <li><strong>è‡ªç”±å¸ƒå±€ä¸å¿«æ·é”®</strong>ï¼š
            <ul>
                <li>ç›´æ¥æ‹–åŠ¨ Logo æˆ–æ–‡å­—è¿›è¡Œå¾®è°ƒã€‚</li>
                <li>æŒ‰ä½ <kbd>Shift</kbd> é”®å¯åŒæ­¥æ‹–åŠ¨ Logo å’Œæ–‡å­—ã€‚</li>
                <li>å½“å…ƒç´ é‡å æ—¶ï¼ŒæŒ‰ä½ <kbd>Ctrl</kbd> é”®å¯å¼ºåˆ¶åªæ‹–åŠ¨æ–‡å­—å±‚ã€‚</li>
            </ul>
        </li>
    </ul>

    <h4>å›¾ç‰‡æ¢æŸ¥å™¨</h4>
    <ul>
        <li><strong>å…¨é¢æœåˆ®</strong>ï¼šè‡ªåŠ¨è§£æ API æ•°æ®ï¼Œæ‰¾å‡ºæ‰€æœ‰ä¸è¯¥æ¸¸æˆç›¸å…³çš„å›¾ç‰‡ä¸è§†é¢‘èµ„æºã€‚</li>
        <li><strong>æ™ºèƒ½åˆ†ç»„</strong>ï¼šå°†æ‰€æœ‰å›¾ç‰‡æŒ‰åˆ†è¾¨ç‡è¿›è¡Œå½’ç±»ï¼Œå¹¶å°†è§†é¢‘å•ç‹¬åˆ†ç»„ã€‚</li>
        <li><strong>æˆªå›¾ç½®é¡¶</strong>ï¼š<code>1920x1080</code> çš„å›¾ç‰‡ä¼šè¢«è¯†åˆ«ä¸ºâ€œæˆªå›¾â€å¹¶ç½®é¡¶æ˜¾ç¤ºã€‚</li>
        <li><strong>è§†é¢‘æ”¯æŒ</strong>ï¼šæ–°å¢â€œå®£ä¼ å½±åƒâ€åˆ†ç±»ï¼Œå¯é¢„è§ˆå°é¢ã€æ’­æ”¾å’Œä¸‹è½½è§†é¢‘ã€‚</li>
        <li><strong>æ‰“åŒ…ä¸‹è½½æˆªå›¾</strong>ï¼šä¸“ç”¨æŒ‰é’®ä¸€é”®å°†æ‰€æœ‰é«˜æ¸…å•†åº—æˆªå›¾æ‰“åŒ…ä¸º ZIP æ–‡ä»¶ä¸‹è½½ã€‚</li>
    </ul>

    <h4>é«˜çº§å›¾ç‰‡è£å‰ª</h4>
    <ul>
        <li><strong>æ‰‹åŠ¨ç²¾è£</strong>ï¼šå†…ç½®å¼ºå¤§çš„å›¾ç‰‡è£å‰ªå·¥å…·ï¼Œæ”¯æŒè‡ªç”±é€‰æ‹©ã€å›ºå®šæ¯”ä¾‹è£å‰ªã€‚</li>
        <li><strong>å®æ—¶æ¯”ä¾‹</strong>ï¼šå½“è¾“å…¥ç›®æ ‡åˆ†è¾¨ç‡æ—¶ï¼Œè£å‰ªæ¡†ä¼šè‡ªåŠ¨é”å®šä¸ºè¯¥å®½é«˜æ¯”ã€‚</li>
        <li><strong>æ‰“åŒ…è£å‰ª</strong>ï¼šæä¾›â€œ<strong>è‡ªåŠ¨è£å‰ªå¹¶æ‰“åŒ…</strong>â€åŠŸèƒ½ï¼Œä¸€é”®å®Œæˆä»¥ä¸‹ä»»åŠ¡å¹¶æ‰“åŒ…æˆ ZIP ä¸‹è½½ï¼š
            <ol>
                <li>è‡ªåŠ¨å¯»æ‰¾ <code>920x430</code> çš„æ¨ªå‘ä¸»å›¾ï¼ˆä¼˜å…ˆä¸­æ–‡ç‰ˆï¼‰ã€‚</li>
                <li>å°†å…¶è‡ªåŠ¨è£å‰ªä¸º <code>474x242</code>, <code>497x278</code>, <code>300x180</code> ä¸‰ç§å°ºå¯¸ã€‚</li>
                <li>è‡ªåŠ¨å¯»æ‰¾å¹¶åŒ…å« <code>300x450</code> çš„çºµå‘å°é¢å›¾ï¼ˆä¼˜å…ˆä¸­æ–‡ç‰ˆï¼‰ã€‚</li>
            </ol>
        </li>
    </ul>
    
    <h4>API æ•°æ®æµè§ˆå™¨</h4>
    <ul>
        <li><strong>ä¸­æ–‡ä¼˜å…ˆ</strong>ï¼šä¼˜å…ˆä»ä¸­æ–‡å•†åº—è·å–â€œå…³äºæ¸¸æˆâ€ã€â€œç®€ä»‹â€ç­‰æ–‡æœ¬ä¿¡æ¯ã€‚</li>
        <li><strong>ç»“æ„åŒ–å±•ç¤º</strong>ï¼šå°†åŸå§‹ JSON æ•°æ®æ•´ç†æˆæ¸…æ™°ã€æ˜“è¯»çš„è¡¨æ ¼ã€‚</li>
        <li><strong>æ™ºèƒ½æ±‰åŒ–</strong>ï¼šå°†å…³é”®å­—æ®µå’Œè¯­è¨€åˆ—è¡¨ç­‰å†…å®¹è¿›è¡Œæ±‰åŒ–ï¼Œæå‡é˜…è¯»ä½“éªŒã€‚</li>
        <li><strong>æ–°å¢ä¿¡æ¯</strong>ï¼šç°åœ¨åŒ…å«â€œå…³äºæ¸¸æˆâ€ã€â€œç®€ä»‹â€ã€â€œPCé…ç½®è¦æ±‚â€ç­‰æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚</li>
    </ul>
</div>


<div class="main-container">
 <div class="header-container">
     <h1>æ«å°ç—•è‡ªå·±çš„steamdb</h1>
     <div class="header-controls">
        <a href="https://github.com/taoyunan/steam-image-viewer" target="_blank" title="æŸ¥çœ‹ GitHub ä»“åº“" style="color: #bbb; text-decoration: none; font-weight: 500; font-size: 16px;">GitHub</a>
        <button id="showTutorialBtn" title="æ˜¾ç¤ºæ•™ç¨‹">?</button>
     </div>
 </div>

 <div class="controls">
    <input type="text" id="appId" placeholder="è¾“å…¥ Steam App ID æˆ–å•†åº—é“¾æ¥" autocomplete="off" />
    <button id="fetchBtn" style="margin-left: 12px;">è·å–</button>
    <button id="saveBtn" disabled style="margin-left: auto;">ä¿å­˜å›¾ç‰‡</button>
    <button id="goToStoreBtn" disabled>å‰å¾€å•†åº—</button>
 </div>

 <div class="controls">
 <textarea id="customText" placeholder="è¾“å…¥è‡ªå®šä¹‰æ–‡å­—ï¼ˆæ”¯æŒå¤šè¡Œï¼‰"></textarea>
 <input type="color" id="textColor" value="#ffffff" title="æ–‡å­—é¢œè‰²" />
 <input type="number" id="textSize" value="24" min="8" max="200" title="æ–‡å­—å¤§å°" />
 <input type="number" id="lineSpacing" value="5" min="0" max="100" title="è¡Œé—´è·" />
 <select id="textFont" title="å­—ä½“">
 <option value="å¾®è½¯é›…é»‘">å¾®è½¯é›…é»‘</option> <option value="é»‘ä½“">é»‘ä½“</option> <option value="Arial">Arial</option> <option value="Times New Roman">Times New Roman</option>
 </select>
 </div>
 <div id="canvas-container">
 <canvas id="heroCanvas" width="1200" height="278" title="æ‹–åŠ¨Logoæˆ–æ–‡å­—å¾®è°ƒä½ç½®"></canvas>
 </div>
 <div class="slider-container">
 <label for="scaleSlider">ç¼©æ”¾ Logo:</label>
 <input type="range" id="scaleSlider" min="10" max="200" value="100" disabled />
 <span id="scalePercent">100%</span>
 </div>
 <div class="controls slider-container" style="margin-top: 15px;">
 <label for="overlaySlider">èƒŒæ™¯æ¸å˜:</label>
 <input type="range" id="overlaySlider" min="0" max="100" value="40" />
 <span id="overlayPercent">40%</span>
 <input type="color" id="gradientColor" value="#000000" title="æ¸å˜é¢œè‰²" />
 <select id="gradientDirection" title="æ¸å˜æ–¹å‘">
 <option value="top-to-bottom">ä»ä¸Šåˆ°ä¸‹</option> <option value="bottom-to-top">ä»ä¸‹åˆ°ä¸Š</option> <option value="left-to-right">ä»å·¦åˆ°å³</option> <option value="right-to-left">ä»å³åˆ°å·¦</option> <option value="tl-to-br">å·¦ä¸Šåˆ°å³ä¸‹</option> <option value="tr-to-bl">å³ä¸Šåˆ°å·¦ä¸‹</option> <option value="bl-to-tr">å·¦ä¸‹åˆ°å³ä¸Š</option> <option value="br-to-tl">å³ä¸‹åˆ°å·¦ä¸Š</option>
 </select>
 </div>
 <div class="status-box"> <div id="loading"></div> <div id="error"></div> </div>
</div>

<div class="controls" style="justify-content: center; margin-top: 20px;">
    <button id="toggleApiBtn" style="display: none;">æŸ¥çœ‹ API æ•°æ®</button>
</div>

<div id="apiViewerContainer" style="display: none;">
 <h3>API æ•°æ®æµè§ˆå™¨</h3>
 <table id="api-table"></table>
</div>

<div id="imageInspector" style="display: none;">
 <h3>å›¾ç‰‡æ¢æŸ¥å™¨</h3>
  <div class="inspector-controls">
     <button id="autoCropBtn" style="background-color: #22c55e;">è‡ªåŠ¨è£å‰ªå¹¶æ‰“åŒ…</button>
     <button id="downloadScreenshotsBtn" style="background-color: #0ea5e9;">æ‰“åŒ…ä¸‹è½½æ‰€æœ‰æˆªå›¾</button>
  </div>
 <div id="imageList"></div>
 <div class="url-actions-container">
     <div class="inspector-controls">
         <button id="copyAllBtn">å¤åˆ¶å…¨éƒ¨é“¾æ¥</button>
         <button id="exportTxtBtn">å¯¼å‡ºä¸º .txt</button>
     </div>
     <textarea id="urlsBox" readonly placeholder="è¿™é‡Œä¼šæ˜¾ç¤ºè¯†åˆ«åˆ°çš„æ‰€æœ‰å›¾ç‰‡é“¾æ¥..."></textarea>
 </div>
</div>

<div id="cropModal">
  <div id="cropContainer">
    <div id="cropImageContainer">
      <img id="cropImage" src="" alt="Cropping Target">
    </div>
    <div class="crop-controls">
      <div class="row">
        <button class="aspect-btn" data-ratio="free">è‡ªç”±</button>
        <button class="aspect-btn" data-ratio="1.777">16:9</button>
        <button class="aspect-btn" data-ratio="1.333">4:3</button>
        <button class="aspect-btn" data-ratio="1">1:1</button>
      </div>
      <div class="row">
          <span>è¾“å‡ºåˆ†è¾¨ç‡:</span>
          <input type="number" id="cropWidth" placeholder="å®½">
          <span>x</span>
          <input type="number" id="cropHeight" placeholder="é«˜">
      </div>
      <div class="row">
          <button id="cropDownloadBtn">è£å‰ªå¹¶ä¸‹è½½</button>
          <button id="cropCancelBtn" style="background-color: #6c757d;">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
<script>
 const API_BASE = "https://api.steamcmd.net/v1/info/";
 const STORE_API_BASE = "https://store.steampowered.com/api/appdetails?appids=";
 const IMG_BASE = "https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/";
 const snapThreshold = 10;
 
 // DOM Elements
 const appIdInput = document.getElementById("appId");
 const canvas = document.getElementById("heroCanvas");
 const ctx = canvas.getContext("2d");
 const errorBox = document.getElementById("error");
 const loadingBox = document.getElementById("loading");
 const scaleSlider = document.getElementById("scaleSlider");
 const scalePercent = document.getElementById("scalePercent");
 const saveBtn = document.getElementById("saveBtn");
 const goToStoreBtn = document.getElementById("goToStoreBtn");
 const overlaySlider = document.getElementById("overlaySlider");
 const overlayPercent = document.getElementById("overlayPercent");
 const imageInspector = document.getElementById("imageInspector");
 const imageList = document.getElementById("imageList");
 const urlsBox = document.getElementById("urlsBox");
 const gradientColorInput = document.getElementById("gradientColor");
 const gradientDirectionSelect = document.getElementById("gradientDirection");
 const toggleApiBtn = document.getElementById("toggleApiBtn");
 const apiViewerContainer = document.getElementById("apiViewerContainer");
 const apiTable = document.getElementById("api-table");
 const cropModal = document.getElementById('cropModal');
 const cropImage = document.getElementById('cropImage');
 const cropWidthInput = document.getElementById('cropWidth');
 const cropHeightInput = document.getElementById('cropHeight');
 
 // Global state variables
 let heroImg = new Image();
 let logoImg = new Image();
 let logoX = 0, logoY = 0, logoScale = 1;
 let customText = "", textColor = "#ffffff", textSize = 24, textFont = "å¾®è½¯é›…é»‘";
 let textX = 20, textY = 20, lineSpacing = 5;
 let overlayOpacity = 0.4;
 let gradientColor = "#000000";
 let gradientDirection = "top-to-bottom";
 let dragging = false;
 let dragTarget = null;
 let dragOffsetX = 0, dragOffsetY = 0;
 let cropper = null;
 let imageCategories = {};
 let videoData = [];
 let screenshotUrls = [];
 let steamTags = new Map();
 let tagsPromise = null;

 // --- HELPER FUNCTIONS ---
 function clearError() { errorBox.textContent = ""; }
 function showError(msg) { errorBox.textContent = msg; }
 function setLoading(msg) { loadingBox.textContent = msg; }
 function clearLoading() { loadingBox.textContent = ""; }
 function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
 
 const get = (obj, path, defaultValue = '') => {
    if (!obj) return defaultValue;
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value !== undefined && value !== null ? value : defaultValue;
 };
 // --- END HELPER FUNCTIONS ---

 function drawHero(img) { const cw = canvas.width, ch = canvas.height; ctx.clearRect(0, 0, cw, ch); if (!img.src) return; const scale = Math.max(cw / img.width, ch / img.height); const w = img.width * scale, h = img.height * scale; ctx.drawImage(img, (cw - w) / 2, (ch - h) / 2, w, h); if (overlayOpacity > 0) { let x0 = 0, y0 = 0, x1 = 0, y1 = 0; switch (gradientDirection) { case 'top-to-bottom': y1 = ch; break; case 'bottom-to-top': y0 = ch; break; case 'left-to-right': x1 = cw; break; case 'right-to-left': x0 = cw; break; case 'tl-to-br': x1 = cw; y1 = ch; break; case 'tr-to-bl': x0 = cw; y1 = ch; break; case 'bl-to-tr': y0 = ch; x1 = cw; break; case 'br-to-tl': x0 = cw; y0 = ch; break; } const g = ctx.createLinearGradient(x0, y0, x1, y1); g.addColorStop(0, hexToRgba(gradientColor, overlayOpacity)); g.addColorStop(1, hexToRgba(gradientColor, 0)); ctx.fillStyle = g; ctx.fillRect(0, 0, cw, ch); } }
 function drawLogo() { if (!logoImg.src || !logoImg.complete) return; ctx.drawImage(logoImg, logoX, logoY, logoImg.width * logoScale, logoImg.height * logoScale); }
 function drawText() { if (!customText) return; ctx.font = `${textSize}px "${textFont}"`; ctx.fillStyle = textColor; ctx.textBaseline = "top"; const lines = customText.split("\n"); lines.forEach((line, i) => { ctx.fillText(line, textX, textY + i * (textSize + lineSpacing)); }); }
 function drawAll() { drawHero(heroImg); drawLogo(); drawText(); }
 function snapToCenterX(objX, objW) { const centerX = (canvas.width - objW) / 2; return Math.abs(objX - centerX) < snapThreshold ? centerX : objX; }
 function snapToCenterY(objY, objH) { const centerY = (canvas.height - objH) / 2; return Math.abs(objY - centerY) < snapThreshold ? centerY : objY; }

 canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale;
    ctx.font = `${textSize}px "${textFont}"`;
    const lines = customText.split("\n");
    const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0;
    const textH = lines.length * (textSize + lineSpacing) - lineSpacing;

    if (e.ctrlKey) {
        dragTarget = "text";
        dragOffsetX = mx - textX;
        dragOffsetY = my - textY;
    } else if (e.shiftKey) {
        dragTarget = "both";
        dragOffsetX = mx - logoX;
        dragOffsetY = my - logoY;
    } else if (logoImg.src && mx >= logoX && mx <= logoX + logoW && my >= logoY && my <= logoY + logoH) {
        dragTarget = "logo";
        dragOffsetX = mx - logoX;
        dragOffsetY = my - logoY;
    } else if (customText && mx >= textX && mx <= textX + textW && my >= textY && my <= textH) {
        dragTarget = "text";
        dragOffsetX = mx - textX;
        dragOffsetY = my - textY;
    }
    
    if (dragTarget) {
        dragging = true;
        canvas.style.cursor = "grabbing";
    }
 });
 canvas.addEventListener("mousemove", (e) => { if (!dragging) return; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale; ctx.font = `${textSize}px "${textFont}"`; const lines = customText.split("\n"); const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0; const textH = lines.length * (textSize + lineSpacing) - lineSpacing; if (dragTarget === "logo" || dragTarget === "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(logoImg.src) { newX = snapToCenterX(newX, logoW); newY = snapToCenterY(newY, logoH); } if (dragTarget === "logo") { logoX = newX; logoY = newY; } else { let offsetX = newX - logoX, offsetY = newY - logoY; logoX = newX; logoY = newY; textX += offsetX; textY += offsetY; } } if (dragTarget === "text" && dragTarget !== "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(customText) { newX = snapToCenterX(newX, textW); newY = snapToCenterY(newY, textH); } textX = newX; textY = newY; } drawAll(); });
 ["mouseup","mouseleave"].forEach(evt => { canvas.addEventListener(evt, () => { dragging = false; dragTarget = null; canvas.style.cursor = "grab"; }); });
 scaleSlider.addEventListener("input", (e) => { logoScale = e.target.value / 100; scalePercent.textContent = `${e.target.value}%`; drawAll(); });
 overlaySlider.addEventListener("input", (e) => { overlayOpacity = e.target.value / 100; overlayPercent.textContent = `${e.target.value}%`; drawAll(); });
 gradientColorInput.addEventListener("input", (e) => { gradientColor = e.target.value; drawAll(); });
 gradientDirectionSelect.addEventListener("change", (e) => { gradientDirection = e.target.value; drawAll(); });
 saveBtn.addEventListener("click", () => { const link = document.createElement("a"); link.download = `steam_${appIdInput.value.trim()}.png`; link.href = canvas.toDataURL("image/png"); link.click(); });
 goToStoreBtn.addEventListener('click', () => { const appId = appIdInput.value.trim(); if (appId) { const storeUrl = `https://store.steampowered.com/app/${appId}/`; window.open(storeUrl, '_blank'); }});
 document.getElementById("customText").addEventListener("input", (e) => { customText = e.target.value; drawAll(); });
 document.getElementById("textColor").addEventListener("input", (e) => { textColor = e.target.value; drawAll(); });
 document.getElementById("textSize").addEventListener("input", (e) => { textSize = parseInt(e.target.value, 10) || 24; drawAll(); });
 document.getElementById("textFont").addEventListener("change", (e) => { textFont = e.target.value; drawAll(); });
 document.getElementById("lineSpacing").addEventListener("input", (e) => { lineSpacing = parseInt(e.target.value, 10) || 0; drawAll(); });
 const tutorialPanel = document.getElementById('tutorial');
 document.getElementById('hideTutorialBtn').addEventListener('click', () => tutorialPanel.classList.add('hidden'));
 document.getElementById('showTutorialBtn').addEventListener('click', () => tutorialPanel.classList.remove('hidden'));
 
 function findImageCandidates(obj) { const results = new Set(); const imageRE = /\.(jpe?g|png|webp|gif)(\?|$)/i; function rec(v) { if (v == null) return; if (typeof v === 'string') { if (imageRE.test(v)) { results.add(v); } } else if (Array.isArray(v)) { for (const e of v) rec(e); } else if (typeof v === 'object') { for (const k in v) rec(v[k]); } } rec(obj); return [...results].map(s => s.split('#')[0].trim()).filter(Boolean); }
 
 function buildFullUrl(appid, candidate) {
     const trimmed = candidate.trim();
     if (/^https?:\/\//i.test(trimmed)) return trimmed;
     const clean = trimmed.replace(/^(\.\/|\/+)/, '');
     return `${IMG_BASE}${encodeURIComponent(appid)}/${clean}`;
 }

 function showAssets(urls, videos) {
     imageList.innerHTML = ''; 
     if (urls.length === 0 && videos.length === 0) { 
         imageList.innerHTML = '<p>æ²¡æœ‰è¯†åˆ«åˆ°ä»»ä½•å›¾ç‰‡æˆ–è§†é¢‘èµ„æºã€‚</p>'; 
         return; 
     } 
     imageList.innerHTML = `<p style="color: #60a5fa; text-align: center;">æ­£åœ¨è·å– ${urls.length} å¼ å›¾ç‰‡å°ºå¯¸ç”¨äºåˆ†ç»„ï¼Œè¯·ç¨å€™...</p>`; 
     imageCategories = {}; 
     const promises = urls.map(u => new Promise(resolve => { 
         const img = new Image(); 
         img.src = u; 
         img.onload = () => resolve({ u, res: `${img.naturalWidth}x${img.naturalHeight}` }); 
         img.onerror = () => resolve({ u, res: 'æœªçŸ¥å°ºå¯¸' }); 
     })); 
     Promise.all(promises).then(results => { 
         results.forEach(({ u, res }) => { 
             if (!imageCategories[res]) imageCategories[res] = []; 
             imageCategories[res].push(u); 
         }); 
         renderCategories(imageCategories, videos); 
     }); 
 }
 
 function createCategoryElement(title, items, isVideo = false) {
    const wrapper = document.createElement('div');
    wrapper.className = 'category';
    const header = document.createElement('div');
    header.className = 'category-header';
    header.innerHTML = `<h4>${title} (${items.length} ${isVideo ? 'ä¸ª' : 'å¼ '})</h4><button class="toggle-btn">å±•å¼€</button>`;
    wrapper.appendChild(header);
    const cardGrid = document.createElement('div');
    cardGrid.className = 'card-grid';

    items.forEach(item => {
        const card = document.createElement('div');
        card.className = 'card';
        if (!isVideo) {
            const u = item;
            if (u.toLowerCase().includes('schinese')) {
                card.classList.add('highlight-schinese');
            }
            const langMatch = u.match(/(schinese|tchinese|english|japanese|koreana|french|german|spanish|latam)/i);
            const lang = langMatch ? langMatch[0] : 'é€šç”¨';
            card.innerHTML = `<img src="${u}" alt="image" class="thumb" loading="lazy" onclick="this.style.objectFit = this.style.objectFit === 'contain' ? 'cover' : 'contain'"><div class="meta">${lang}</div><div class="actions"><button data-url="${u}" class="open-btn">æ‰“å¼€</button><button data-url="${u}" class="copy-btn">å¤åˆ¶</button><button data-url="${u}" class="crop-btn">è£å‰ª</button><button data-url="${u}" class="dl-btn">ä¸‹è½½</button></div>`;
        } else { // Video card
            const video = item;
            card.innerHTML = `
                <img src="${video.thumbnail}" alt="${video.name}" class="thumb" loading="lazy">
                <div class="meta" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${video.name}">${video.name}</div>
                <div class="actions">
                    <button data-url="${video.thumbnail}" class="open-btn">å°é¢</button>
                    <button data-url="${video.thumbnail}" class="dl-btn">ä¸‹å°é¢</button>
                    <button data-url="${video.mp4.max}" class="open-btn" style="background-color:#e11d48;">æ’­æ”¾</button>
                    <button data-url="${video.mp4.max}" class="dl-btn" style="background-color:#e11d48;">ä¸‹è§†é¢‘</button>
                </div>`;
        }
        cardGrid.appendChild(card);
    });

    wrapper.appendChild(cardGrid);
    const toggleBtn = header.querySelector('.toggle-btn');
    toggleBtn.onclick = () => {
        const isHidden = cardGrid.style.display === 'none';
        cardGrid.style.display = isHidden ? 'grid' : 'none';
        toggleBtn.textContent = isHidden ? 'æŠ˜å ' : 'å±•å¼€';
    };
    return wrapper;
 }

 function renderCategories(categories, videos) {
     imageList.innerHTML = '';
     
     if (categories['1920x1080']) {
         const screenshotElement = createCategoryElement('æˆªå›¾', categories['1920x1080']);
         imageList.appendChild(screenshotElement);
         delete categories['1920x1080'];
     }
     
     if (videos && videos.length > 0) {
        const videoElement = createCategoryElement('å®£ä¼ å½±åƒ', videos, true);
        imageList.appendChild(videoElement);
     }

     const sortedKeys = Object.keys(categories).sort((a, b) => { 
         if (a === 'æœªçŸ¥å°ºå¯¸') return 1; 
         if (b === 'æœªçŸ¥å°ºå¯¸') return -1; 
         const [wA, hA] = a.split('x').map(Number); 
         const [wB, hB] = b.split('x').map(Number); 
         return (wB * hB) - (wA * hA);
     }); 
     sortedKeys.forEach(res => { 
         const urls = categories[res]; 
         const categoryElement = createCategoryElement(`åˆ†è¾¨ç‡: ${res}`, urls);
         imageList.appendChild(categoryElement);
     }); 
 }

 imageList.addEventListener('click', e => { const target = e.target; const url = target.dataset.url; if (!url) return; if (target.classList.contains('open-btn')) { window.open(url, '_blank'); } else if (target.classList.contains('copy-btn')) { navigator.clipboard.writeText(url).then(() => { setLoading('é“¾æ¥å·²å¤åˆ¶!'); setTimeout(clearLoading, 1500); }); } else if (target.classList.contains('dl-btn')) { downloadImage(url); } else if (target.classList.contains('crop-btn')) { cropImage.src = url; cropModal.style.display = 'flex'; cropImage.onload = () => { if(cropper) { cropper.destroy(); } cropper = new Cropper(cropImage, { viewMode: 1, background: false, autoCropArea: 0.9 }); }; } });
 document.getElementById('copyAllBtn').addEventListener('click', () => { if (!urlsBox.value) return; navigator.clipboard.writeText(urlsBox.value).then(() => { setLoading('å…¨éƒ¨é“¾æ¥å·²å¤åˆ¶!'); setTimeout(clearLoading, 1500); }); });
 document.getElementById('exportTxtBtn').addEventListener('click', () => { if (!urlsBox.value) return; const blob = new Blob([urlsBox.value], {type:'text/plain;charset=utf-8'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `steam_${appIdInput.value.trim()}_assets.txt`; a.click(); URL.revokeObjectURL(a.href); });
 document.getElementById('cropDownloadBtn').addEventListener('click', () => { if (!cropper) return; const cropWidth = parseInt(cropWidthInput.value, 10); const cropHeight = parseInt(cropHeightInput.value, 10); const options = {}; if (!isNaN(cropWidth) && cropWidth > 0) options.width = cropWidth; if (!isNaN(cropHeight) && cropHeight > 0) options.height = cropHeight; const canvas = cropper.getCroppedCanvas(options); const link = document.createElement('a'); link.download = `cropped_${appIdInput.value.trim()}_${Date.now()}.png`; link.href = canvas.toDataURL('image/png'); link.click(); document.getElementById('cropCancelBtn').click(); });
 document.getElementById('cropCancelBtn').addEventListener('click', () => { cropModal.style.display = 'none'; if (cropper) { cropper.destroy(); cropper = null; } cropImage.src = ''; cropWidthInput.value = ''; cropHeightInput.value = ''; });
 document.querySelectorAll('.aspect-btn').forEach(btn => { btn.addEventListener('click', (e) => { if (!cropper) return; const ratio = e.target.dataset.ratio; cropper.setAspectRatio(ratio === 'free' ? NaN : parseFloat(ratio)); cropWidthInput.value = ''; cropHeightInput.value = ''; }); });
 
 function updateCropAspectRatio() { if (!cropper) return; const width = parseFloat(cropWidthInput.value); const height = parseFloat(cropHeightInput.value); if (width > 0 && height > 0) { cropper.setAspectRatio(width / height); } else { cropper.setAspectRatio(NaN); } }
 cropWidthInput.addEventListener('input', updateCropAspectRatio);
 cropHeightInput.addEventListener('input', updateCropAspectRatio);

function buildApiTable(appData, storeData, playerCount, reviewSummary) {
    const data = appData.data || {};
    const common = appData.common || {};
    let html = '';

    const addRow = (label, value) => {
        if (value === '' || value === undefined || value === null || (Array.isArray(value) && value.length === 0)) return;
        html += `<tr><td>${label}</td><td>${value}</td></tr>`;
    };

    const addSection = (title) => {
        html += `<tr class="api-section-header"><td colspan="2">${title}</td></tr>`;
    };
    
    const formatChineseDate = (ts) => {
        if (!ts || isNaN(ts)) return 'N/A';
        const date = new Date(ts * 1000);
        return date.toLocaleString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit', second: '2-digit' });
    };
    
    const englishName = get(common, 'name', 'åŸºæœ¬ä¿¡æ¯');
    const chineseName = get(common, 'name_localized.schinese');
    let titleHtml = '';
    if (chineseName) {
        titleHtml += `<p class="api-game-title-zh">${chineseName}</p><p class="api-game-title">${englishName}</p>`;
    } else {
        titleHtml += `<p class="api-game-title-zh">${englishName}</p>`;
    }
    html += `<tr class="api-title-header"><td colspan="2">${titleHtml}</td></tr>`;
    
    addSection('åŸºæœ¬ä¿¡æ¯');
    addRow('APP ID', get(data, 'steam_appid'));
    const typeMap = { game: 'æ¸¸æˆ', dlc: 'DLC', application: 'åº”ç”¨', music: 'éŸ³ä¹', video: 'è§†é¢‘', series: 'å‰§é›†', hardware: 'ç¡¬ä»¶' };
    const appType = get(common, 'type', '');
    addRow('APP ç±»å‹', typeMap[appType.toLowerCase()] || appType);
    
    let developers = get(data, 'developers', []);
    if (!Array.isArray(developers)) developers = [developers];
    const devHtml = developers.map(d => `<a href="#">${d}</a>`).join(', ');
    addRow('å¼€å‘å•†', devHtml);

    let publishers = get(data, 'publishers', []);
    if (!Array.isArray(publishers)) publishers = [publishers];
    const pubHtml = publishers.map(p => `<a href="#">${p}</a>`).join(', ');
    addRow('å‘è¡Œå•†', pubHtml);

    if (storeData) {
        if (storeData.is_free) { addRow('ä»·æ ¼', 'å…è´¹æ¸¸ç©'); }
        else if (storeData.price_overview) {
            const price = storeData.price_overview;
            let priceHtml = `${price.final_formatted}`;
            if (price.discount_percent > 0) {
                priceHtml += ` <span style="color:#a1e196;">(-${price.discount_percent}%)</span> (åŸä»·: ${price.initial_formatted})`;
            }
            addRow('ä»·æ ¼', priceHtml);
        }
        
        if (storeData.platforms) {
            let platformsHtml = '';
            if (storeData.platforms.windows) platformsHtml += `<span class="platform-icon" title="Windows">ğŸªŸ</span>`;
            if (storeData.platforms.mac) platformsHtml += `<span class="platform-icon" title="macOS">ï£¿</span>`;
            if (storeData.platforms.linux) platformsHtml += `<span class="platform-icon" title="Linux / SteamOS">ğŸ§</span>`;
            addRow('æ”¯æŒå¹³å°', platformsHtml);
        }
        
        if (storeData.metacritic) {
            addRow('Metacritic è¯„åˆ†', `<a href="${storeData.metacritic.url}" target="_blank">${storeData.metacritic.score}</a>`);
        }
        
        if(storeData.genres) {
            const genresHtml = storeData.genres.map(g => `<span class="api-tag">${g.description}</span>`).join(' ');
            addRow('åˆ†ç±»', genresHtml);
        }
        if(storeData.categories) {
            const categoriesHtml = storeData.categories.map(c => `<span class="api-tag">${c.description}</span>`).join(' ');
            addRow('å°åˆ†ç±»', categoriesHtml);
        }
    }
    
    const storeTagsObject = get(common, 'store_tags', {});
    const playerTags = Object.values(storeTagsObject)
        .map(tagId => steamTags.get(tagId))
        .filter(Boolean);
    if (playerTags.length > 0) {
        const tagsHtml = playerTags.map(tagName => `<span class="api-tag">${tagName}</span>`).join(' ');
        addRow('ç©å®¶æ ‡ç­¾', tagsHtml);
    }
    
    addSection('ç©å®¶æ•°æ®');
    if (playerCount !== null && playerCount >= 0) { addRow('å½“å‰åœ¨çº¿äººæ•°', playerCount.toLocaleString()); }
    
    if (reviewSummary && reviewSummary.total_reviews > 0) {
        const totalReviews = reviewSummary.total_positive + reviewSummary.total_negative;
        if (totalReviews > 0) {
            const positiveRate = (reviewSummary.total_positive / totalReviews * 100).toFixed(1);
            addRow('å¥½è¯„ç‡', `<b>${positiveRate}%</b> (${reviewSummary.review_score_desc})`);
            addRow('è¯„æµ‹æ€»æ•°', totalReviews.toLocaleString());
        }
    }
    
    addSection('å‘å¸ƒä¿¡æ¯');
    addRow('å•†åº—é¡µå‘è¡Œæ—¥æœŸ', formatChineseDate(get(common, 'steam_release_date')));
    addRow('å‘å¸ƒçŠ¶æ€', get(common, 'releasestate'));
    addRow('æœ€åæ›´æ–°æ—¶é—´', formatChineseDate(get(common, 'last_record_update')));
    addRow('Last Changenumber', get(common, 'last_changenumber'));
    
    if (storeData) {
        addSection('PC é…ç½®è¦æ±‚');
        addRow('æœ€ä½é…ç½®', get(storeData, 'pc_requirements.minimum', 'æ— '));
        addRow('æ¨èé…ç½®', get(storeData, 'pc_requirements.recommended', 'æ— '));
    }
    
    const localized = get(common, 'name_localized');
    if (localized && Object.keys(localized).length > 1) {
        addSection('æœ¬åœ°åŒ–åç§°');
        const langMap = {'english':'è‹±è¯­','japanese':'æ—¥è¯­','schinese':'ç®€ä½“ä¸­æ–‡','tchinese':'ç¹ä½“ä¸­æ–‡','french':'æ³•è¯­','german':'å¾·è¯­','italian':'æ„å¤§åˆ©è¯­','koreana':'éŸ©è¯­','spanish':'è¥¿ç­ç‰™è¯­','russian':'ä¿„è¯­','thai':'æ³°è¯­','portuguese':'è‘¡è„ç‰™è¯­','polish':'æ³¢å…°è¯­','danish':'ä¸¹éº¦è¯­','dutch':'è·å…°è¯­','finnish':'èŠ¬å…°è¯­','norwegian':'æŒªå¨è¯­','swedish':'ç‘å…¸è¯­','hungarian':'åŒˆç‰™åˆ©è¯­','czech':'æ·å…‹è¯­','romanian':'ç½—é©¬å°¼äºšè¯­','turkish':'åœŸè€³å…¶è¯­','arabic':'é˜¿æ‹‰ä¼¯è¯­','bulgarian':'ä¿åŠ åˆ©äºšè¯­','greek':'å¸Œè…Šè¯­','ukrainian':'ä¹Œå…‹å…°è¯­','vietnamese':'è¶Šå—è¯­','brazilian':'å·´è¥¿è‘¡è„ç‰™è¯­','latam':'æ‹‰ä¸ç¾æ´²è¥¿ç­ç‰™è¯­'};
        Object.entries(localized).forEach(([lang, name]) => {
            if(lang !== 'schinese') addRow(langMap[lang] || lang, name)
        });
    }
    
    const langValue = get(data, 'supported_languages');
    if (langValue) {
        addSection("æ”¯æŒçš„è¯­è¨€");
        const langMap = {'english': 'è‹±è¯­', 'japanese': 'æ—¥è¯­', 'french': 'æ³•è¯­', 'italian': 'æ„å¤§åˆ©è¯­', 'german': 'å¾·è¯­', 'spanish': 'è¥¿ç­ç‰™è¯­ - è¥¿ç­ç‰™', 'brazilian': 'è‘¡è„ç‰™è¯­ - å·´è¥¿', 'russian': 'ä¿„è¯­', 'schinese': 'ç®€ä½“ä¸­æ–‡', 'tchinese': 'ç¹ä½“ä¸­æ–‡', 'koreana': 'éŸ©è¯­'};
        let langTable = '<table class="language-table"><thead><tr><th>è¯­è¨€</th><th>ç•Œé¢</th><th>éŸ³é¢‘</th><th>å­—å¹•</th></tr></thead><tbody>';
        Object.entries(langValue).forEach(([lang, support]) => {
            if (support.supported) {
                langTable += `<tr><td>${langMap[lang] || lang}</td><td class="support-cell"><span class="check-mark">âœ”</span></td><td class="support-cell">${support.full_audio ? '<span class="check-mark">âœ”</span>' : ''}</td><td class="support-cell">${support.subtitles ? '<span class="check-mark">âœ”</span>' : ''}</td></tr>`;
            }
        });
        langTable += '</tbody></table>';
        html += `<tr><td></td><td>${langTable}</td></tr>`;
    }

    if (storeData && storeData.movies && storeData.movies.length > 0) {
        addSection('å®£ä¼ å½±åƒ');
        storeData.movies.forEach(movie => {
            if (movie.mp4 && movie.mp4.max) { addRow(movie.name, `<a href="${movie.mp4.max}" target="_blank">${movie.mp4.max}</a>`); }
        });
    }

    apiTable.innerHTML = html;
}
 
 async function fetchData(appId) {
    try {
        await tagsPromise; // Ensure tags are loaded before proceeding
    } catch (error) {
        // Error is already logged in loadSteamTags, just continue gracefully
    }

    clearError(); setLoading("æ­£åœ¨è¯·æ±‚API...");
    saveBtn.disabled = true; goToStoreBtn.disabled = true; scaleSlider.disabled = true; 
    toggleApiBtn.style.display = 'none'; apiViewerContainer.style.display = 'none';
    imageInspector.style.display = 'none'; imageList.innerHTML = ''; urlsBox.value = '';
    screenshotUrls = []; videoData = [];

    try {
        const proxyUrl = 'https://corsproxy.io/?';
        const storeApiUrl = `${STORE_API_BASE}${appId}&l=schinese&cc=cn`;
        const playerApiUrl = `https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid=${appId}`;
        const reviewsApiUrl = `https://store.steampowered.com/appreviews/${appId}?json=1&language=all`;
        
        const [steamCmdRes, storeRes, playerRes, reviewsRes] = await Promise.all([
            fetch(API_BASE + appId),
            fetch(proxyUrl + encodeURIComponent(storeApiUrl)),
            fetch(proxyUrl + encodeURIComponent(playerApiUrl)),
            fetch(proxyUrl + encodeURIComponent(reviewsApiUrl))
        ]);

        if (!steamCmdRes.ok) throw new Error(`SteamCMD API è¯·æ±‚å¤±è´¥: ${steamCmdRes.status}`);
        
        const steamCmdJson = await steamCmdRes.json();
        const appData = steamCmdJson.data?.[appId];
        if (!appData) { throw new Error(steamCmdJson.message || "æœªæ‰¾åˆ°æ¸¸æˆæ•°æ®æˆ–APIè¿”å›æ ¼å¼æ— æ•ˆ"); }
        
        let storeData = null;
        if (storeRes.ok) {
            const storeJson = await storeRes.json();
            if (storeJson[appId]?.success) { storeData = storeJson[appId].data; }
        } else { console.warn(`å•†åº— API è¯·æ±‚å¤±è´¥: ${storeRes.status}`); }
        
        let playerCount = null;
        if (playerRes.ok) {
            const playerJson = await playerRes.json();
            if (playerJson.response?.result === 1) { playerCount = playerJson.response.player_count; }
        } else { console.warn(`ç©å®¶æ•°é‡ API è¯·æ±‚å¤±è´¥: ${playerRes.status}`); }

        let reviewSummary = null;
        if (reviewsRes.ok) {
            const reviewsJson = await reviewsRes.json();
            if (reviewsJson.success === 1) { reviewSummary = reviewsJson.query_summary; }
        } else { console.warn(`è¯„æµ‹ API è¯·æ±‚å¤±è´¥: ${reviewsRes.status}`); }
        
        buildApiTable(appData, storeData, playerCount, reviewSummary);
        toggleApiBtn.style.display = 'block';
        
        setLoading("æ­£åœ¨åŠ è½½æ‹¼å›¾èµ„æº...");
        let gameName = get(appData, 'common.name_localized.schinese', get(appData, 'common.name', ''));
        customText = `3DMã€Š${gameName}ã€‹ä¸“åŒº`;
        document.getElementById("customText").value = customText;
        
        const assetsFull = appData.common?.library_assets_full;
        if (!assetsFull) throw new Error("ç¼ºå°‘ library_assets_full æ•°æ®");
        const heroPath = assetsFull.library_hero?.image?.english;
        let logoPath = assetsFull.library_logo?.image?.schinese || assetsFull.library_logo?.image?.english;
        if (!heroPath) throw new Error("æœªæ‰¾åˆ° library_hero å›¾ç‰‡");
        
        const heroUrl = IMG_BASE + appId + "/" + heroPath;
        let logoUrl = logoPath ? IMG_BASE + appId + "/" + logoPath : `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`;
        
        heroImg = new Image(); heroImg.crossOrigin = "anonymous"; heroImg.src = heroUrl;
        logoImg = new Image(); logoImg.crossOrigin = "anonymous"; logoImg.src = logoUrl;
        
        await Promise.all([
            new Promise((res, rej) => { heroImg.onload = res; heroImg.onerror = () => rej(new Error('èƒŒæ™¯å›¾åŠ è½½å¤±è´¥')); }),
            new Promise((res) => { logoImg.onload = res; logoImg.onerror = () => { logoImg.src = `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`; logoImg.onload = res; logoImg.onerror = res; }; }),
        ]);
        
        drawHero(heroImg);
        if(logoImg.complete && logoImg.naturalWidth > 0) {
           logoScale = (0.2 * canvas.width) / logoImg.width;
           logoX = (canvas.width - (logoImg.width * logoScale)) / 2;
           logoY = (canvas.height - (logoImg.height * logoScale)) / 2;
           scaleSlider.value = Math.round(logoScale * 100);
           scalePercent.textContent = `${Math.round(logoScale * 100)}%`;
           scaleSlider.disabled = false;
        } else { logoImg.src = ''; scaleSlider.disabled = true; }

        saveBtn.disabled = false;
        goToStoreBtn.disabled = false;

        ctx.font = `${textSize}px "${textFont}"`;
        const lines = customText.split("\n");
        const textW = Math.max(...lines.map(line => ctx.measureText(line).width));
        const textH = lines.length * (textSize + lineSpacing) - lineSpacing;
        textX = (canvas.width - textW) / 2;
        textY = (canvas.height - textH) / 2 + 30;
        drawAll();

        setLoading("æ­£åœ¨è§£æå›¾ç‰‡ä¸è§†é¢‘èµ„æº...");
        let candidates = findImageCandidates(steamCmdJson);
        let allImageUrls = [...new Set(candidates.map(c => buildFullUrl(appId, c)))];
        let allAssetUrlsForTxt = [...allImageUrls];

        if (storeData?.screenshots) {
            screenshotUrls = storeData.screenshots.map(ss => ss.path_full);
            allImageUrls.push(...screenshotUrls);
            allImageUrls = [...new Set(allImageUrls)];
            allAssetUrlsForTxt.push(...screenshotUrls);
        }
        
        if (storeData?.movies) {
            videoData = storeData.movies.filter(m => m.mp4 && m.mp4.max);
            videoData.forEach(v => {
                allAssetUrlsForTxt.push(v.thumbnail);
                allAssetUrlsForTxt.push(v.mp4.max);
            });
        }

        imageInspector.style.display = 'block';
        if (allImageUrls.length > 0 || videoData.length > 0) {
            urlsBox.value = [...new Set(allAssetUrlsForTxt)].join('\n');
            showAssets(allImageUrls, videoData);
        } else {
            imageList.innerHTML = '<p>æœªèƒ½è‡ªåŠ¨è¯†åˆ«åˆ°ä»»ä½•å›¾ç‰‡æˆ–è§†é¢‘èµ„æºã€‚</p>';
        }
        clearLoading();
    } catch (e) {
        showError(e.message || "æœªçŸ¥é”™è¯¯");
        clearLoading();
    }
}
 
 function downloadImage(url, filename) {
     setLoading('æ­£åœ¨å‡†å¤‡ä¸‹è½½...');
     fetch(url)
        .then(response => response.blob())
        .then(blob => {
            saveAs(blob, filename || url.split('/').pop().split('?')[0] || `asset.tmp`);
            clearLoading();
        })
        .catch(err => {
            showError(`ä¸‹è½½å¤±è´¥: ${err.message}. æ­£åœ¨å°è¯•ç›´æ¥æ‰“å¼€...`);
            clearLoading();
            window.open(url, '_blank');
        });
 }

 async function performCropAndGetBlob(sourceUrl, targetWidth, targetHeight) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const proxyUrl = 'https://corsproxy.io/?';
        img.src = proxyUrl + encodeURIComponent(sourceUrl);
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');
            const sourceAspect = img.width / img.height;
            const targetAspect = targetWidth / targetHeight;
            let sx, sy, sWidth, sHeight;

            if (sourceAspect > targetAspect) {
                sHeight = img.height; sWidth = sHeight * targetAspect;
                sx = (img.width - sWidth) / 2; sy = 0;
            } else {
                sWidth = img.width; sHeight = sWidth / targetAspect;
                sx = 0; sy = (img.height - sHeight) / 2;
            }
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);
            canvas.toBlob(blob => {
                if (blob) { resolve(blob); } else { reject(new Error('Canvas toBlob failed')); }
            }, 'image/png');
        };
        img.onerror = () => reject(new Error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${sourceUrl}`));
    });
 }
 
 async function autoCropAndZip() {
    const appId = appIdInput.value.trim(); if (!appId) return;
    const zip = new JSZip();
    const findImage = (resolution) => {
        const urls = imageCategories[resolution] || [];
        return urls.find(u => u.includes('schinese')) || urls[0] || null;
    };
    const source920 = findImage('920x430');
    const source300 = findImage('300x450');
    let tasks = [];

    if (source300) {
        tasks.push(async () => {
            try {
                setLoading("æ­£åœ¨è·å– 300x450 å›¾...");
                const response = await fetch(source300);
                if (!response.ok) throw new Error('Network response was not ok.');
                const blob = await response.blob();
                zip.file(`${appId}_300x450.png`, blob);
            } catch (e) { showError(`è·å– 300x450 å›¾å¤±è´¥: ${e.message}`); }
        });
    } else { showError("æœªæ‰¾åˆ° 300x450 å›¾ç‰‡ã€‚"); }

    if (source920) {
        const cropTargets = [ { w: 474, h: 242 }, { w: 497, h: 278 }, { w: 300, h: 180 } ];
        cropTargets.forEach(target => {
            tasks.push(async () => {
                try {
                    setLoading(`æ­£åœ¨è£å‰ª ${target.w}x${target.h} å›¾...`);
                    const blob = await performCropAndGetBlob(source920, target.w, target.h);
                    zip.file(`${appId}_${target.w}x${target.h}.png`, blob);
                } catch (e) { showError(`è£å‰ª ${target.w}x${target.h} å¤±è´¥: ${e.message}`); }
            });
        });
    } else { showError("æœªæ‰¾åˆ° 920x430 å›¾ç‰‡ç”¨äºè£å‰ªã€‚"); }

    if (tasks.length === 0) { clearLoading(); showError("æœªæ‰¾åˆ°ä»»ä½•ç¬¦åˆæ¡ä»¶çš„å›¾ç‰‡ã€‚"); return; }
    for (const task of tasks) { await task(); }
    if (Object.keys(zip.files).length === 0) { clearLoading(); showError("æ‰€æœ‰å›¾ç‰‡å¤„ç†å‡å¤±è´¥ï¼Œæ— æ³•åˆ›å»º ZIPã€‚"); return; }
    
    setLoading('æ­£åœ¨ç”Ÿæˆ ZIP æ–‡ä»¶...');
    try {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${appId}_covers.zip`);
        setLoading('æ‰“åŒ…ä¸‹è½½å·²å¼€å§‹ï¼');
    } catch (e) {
        showError(`ç”Ÿæˆ ZIP å¤±è´¥: ${e.message}`);
    } finally {
        setTimeout(clearLoading, 2000);
    }
 }

 async function downloadAssetsAsZip(assets, zipFilename) {
    const zip = new JSZip(); let fetchedCount = 0;
    const assetPromises = assets.map(async (asset) => {
        try {
            const response = await fetch(asset.url);
            if (!response.ok) throw new Error(`Failed to fetch ${asset.filename}`);
            const blob = await response.blob();
            fetchedCount++; setLoading(`æ­£åœ¨è·å–èµ„æº (${fetchedCount}/${assets.length})...`);
            return { filename: asset.filename, blob: blob };
        } catch (e) { console.error(e); showError(`è·å– ${asset.filename} å¤±è´¥`); return null; }
    });
    const fetchedAssets = (await Promise.all(assetPromises)).filter(Boolean);
    if (fetchedAssets.length === 0) { showError("æ‰€æœ‰èµ„æºè·å–å¤±è´¥ï¼Œæ— æ³•åˆ›å»º ZIP æ–‡ä»¶ã€‚"); clearLoading(); return; }
    fetchedAssets.forEach(asset => zip.file(asset.filename, asset.blob));
    setLoading('æ­£åœ¨ç”Ÿæˆ ZIP æ–‡ä»¶ï¼Œè¯·ç¨å€™...');
    try {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, zipFilename);
        setLoading('ZIP æ–‡ä»¶å·²å¼€å§‹ä¸‹è½½ï¼');
    } catch (e) {
        showError(`ç”Ÿæˆ ZIP æ–‡ä»¶å¤±è´¥: ${e.message}`);
    } finally {
        setTimeout(clearLoading, 2000);
    }
}

 async function downloadAllScreenshots() {
    if (screenshotUrls.length === 0) { showError("æ²¡æœ‰å¯ä¸‹è½½çš„æˆªå›¾ã€‚"); return; }
    const appId = appIdInput.value.trim(); if (!appId) return;
    const assetsToZip = screenshotUrls.map((url, i) => ({ url: url, filename: `${appId}_screenshot_${i + 1}.jpg` }));
    await downloadAssetsAsZip(assetsToZip, `${appId}_screenshots.zip`);
 }

 function loadSteamTags() {
    const proxyUrl = 'https://corsproxy.io/?';
    const tagsApiUrl = 'https://store.steampowered.com/tagdata/populartags/schinese';
    return fetch(proxyUrl + encodeURIComponent(tagsApiUrl))
        .then(response => {
            if (!response.ok) throw new Error('Failed to fetch Steam tags');
            return response.json();
        })
        .then(tagsData => {
            tagsData.forEach(tag => steamTags.set(String(tag.tagid), tag.name));
            console.log(`Loaded ${steamTags.size} Steam tags.`);
        })
        .catch(error => {
            console.error("Error fetching Steam tags:", error);
            // Don't show an error to the user, just log it. The app can function without tags.
        });
 }

 document.getElementById("fetchBtn").addEventListener("click", () => {
     const rawInput = appIdInput.value.trim();
     let appId = rawInput;
     const urlMatch = rawInput.match(/store\.steampowered\.com\/app\/(\d+)/);
     if (urlMatch && urlMatch[1]) { appId = urlMatch[1]; appIdInput.value = appId; }
     if (!/^\d+$/.test(appId)) { showError("è¯·è¾“å…¥æœ‰æ•ˆçš„ Steam App ID æˆ–å•†åº—é“¾æ¥"); return; }
     fetchData(appId);
 });
 
 toggleApiBtn.addEventListener('click', () => {
     const isHidden = apiViewerContainer.style.display === 'none';
     apiViewerContainer.style.display = isHidden ? 'block' : 'none';
     toggleApiBtn.textContent = isHidden ? 'éšè— API æ•°æ®' : 'æŸ¥çœ‹ API æ•°æ®';
     if(isHidden) { window.scroll({ top: toggleApiBtn.offsetTop - 20, behavior: 'smooth' }); }
 });
 
 document.getElementById("autoCropBtn").addEventListener('click', autoCropAndZip);
 document.getElementById("downloadScreenshotsBtn").addEventListener('click', downloadAllScreenshots);
 
 window.addEventListener('DOMContentLoaded', () => {
    tagsPromise = loadSteamTags(); // Pre-fetch all tags on page load and store the promise
    const params = new URLSearchParams(window.location.search);
    const appIdFromUrl = params.get("appid");
    if (appIdFromUrl) { appIdInput.value = appIdFromUrl; fetchData(appIdFromUrl); }
 });

</script>
</body>
</html>
