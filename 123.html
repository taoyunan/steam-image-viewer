<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>枫小痕自己的steamdb</title>
<style>
 @import url('https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap');
 /* ... CSS ... */
 * { box-sizing: border-box; }
 body {
 background: #121417; color: #e0e0e0; font-family: 'Roboto Slab', "微软雅黑", sans-serif;
 display: flex; flex-direction: column; align-items: center;
 padding: 25px 15px 40px; min-height: 100vh; user-select:none;
 }
 .main-container, #imageInspector, #apiViewerContainer {
 width: 100%; max-width: 1200px;
 }
 .header-container {
 display: flex; align-items: center; gap: 15px; margin-bottom: 20px;
 }
 h1 {
 margin: 0; font-weight: 700; font-size: 2.4rem; letter-spacing: 2px;
 color: #60a5fa; text-shadow: 0 0 10px #60a5faaa;
 }
 .controls {
 display: flex; gap: 12px; margin-bottom: 15px;
 width: 100%; max-width: 820px; flex-wrap: wrap; align-items: center;
 }
 input, button, select, textarea {
 border-radius: 8px; border: none; font-size: 14px;
 outline: none; transition: all 0.25s ease; font-weight: 500;
 }
 input[type="text"], input[type="number"], select, textarea {
 background: #23262a; color: #ddd; padding: 8px 12px;
 box-shadow: inset 0 0 6px #0008;
 }
 input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
 background: #2b2e34; box-shadow: inset 0 0 8px #60a5faaa; color: #eef3ff;
 }
 #appId {
 height: 36px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 button {
 background: #3b82f6; color: white; cursor: pointer; padding: 10px 22px;
 font-weight: 700; box-shadow: 0 4px 15px #3b82f6bb; flex: none; user-select:none;
 }
 button:disabled { background: #606c8f; cursor: not-allowed; box-shadow: none; }
 button:hover:not(:disabled) { background: #2563eb; box-shadow: 0 6px 20px #2563ebcc; }
 #customText {
 resize: vertical; min-height: 60px; max-height: 120px;
 padding: 8px 12px; line-height: 20px; flex: 1 1 auto; min-width: 0;
 }
 input[type="color"] {
 min-width: 48px; height: 36px; padding: 2px; cursor: pointer; flex: none;
 border-radius: 8px; border: 2px solid transparent; transition: border-color 0.2s ease;
 background: #23262a;
 }
 input[type="color"]:focus { border-color: #60a5fa; }
 input[type="number"] { width: 80px; height: 36px; text-align: center; flex: none; }
 select { width: 150px; cursor: pointer; height: 36px; flex: none; }
 #canvas-container {
 background: #171c29; width: 100%; max-width: 1200px; height: 278px;
 position: relative; overflow: visible; box-shadow: 0 0 25px #2563eb44 inset;
 border-radius: 12px; cursor: grab; margin: 0 auto;
 }
 canvas { display: block; user-select: none; border-radius: 12px; }
 .slider-container, .main-container .controls {
 margin-left: auto; margin-right: auto;
 }
 .slider-container {
 margin-top: 15px; width: 100%; max-width: 600px; display: flex;
 align-items: center; gap: 15px; color: #bbb; user-select:none;
 }
 input[type="range"] { 
 flex: 1; -webkit-appearance: none; height: 6px; border-radius: 6px;
 background: #4b6cb7; cursor: pointer; transition: background-color 0.2s ease;
 }
 input[type="range"]:hover { background: #3b82f6; }
 input[type="range"]::-webkit-slider-thumb {
 -webkit-appearance: none; width: 16px; height: 16px; background: #60a5fa;
 border-radius: 50%; cursor: pointer; box-shadow: 0 0 8px #60a5faaa;
 transition: background-color 0.2s ease;
 }
 input[type="range"]:active::-webkit-slider-thumb { background: #2563eb; box-shadow: 0 0 12px #2563ebcc; }
 #scalePercent, #overlayPercent { min-width: 45px; font-weight: 600; color: #60a5fa; }
 .status-box { margin-top: 18px; min-height: 1.5em; text-align: center; font-weight: 700; width: 100%; max-width: 820px; }
 #error { color: #ef4444; }
 #loading { color: #60a5fa; }
 #tutorial {
 position: fixed; top: 20px; right: 20px; width: 320px; z-index: 1000;
 padding: 20px 25px; background: #1e2433ee; backdrop-filter: blur(8px);
 border-radius: 14px; font-size: 14px; line-height: 1.7; border: 1px solid #2e3a59;
 box-shadow: 0 8px 30px rgba(0,0,0,0.4); max-height: calc(100vh - 40px);
 overflow-y: auto; transition: opacity 0.3s ease, transform 0.3s ease;
 }
 #tutorial.hidden {
 opacity: 0; transform: translateX(20px); pointer-events: none;
 }
 .tutorial-header { display: flex; justify-content: space-between; align-items: center; }
 #tutorial h3 { margin: 0 0 12px; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; }
 #tutorial ul { list-style-type: disc; padding-left: 20px; color: #ccc; margin: 0; }
 #tutorial ul li { margin-bottom: 10px; }
 .toggle-tutorial-btn {
 background: none; border: 1px solid #4b6cb7; color: #bbb;
 padding: 4px 10px; font-size: 12px; cursor: pointer; box-shadow: none;
 }
 #showTutorialBtn {
 font-size: 20px; padding: 0 10px; background: #23262a;
 border: 1px solid #2e3a59; box-shadow: none;
 }
 #imageInspector {
 text-align: left; margin-top: 36px; padding: 20px 25px; background: #1e2433;
 border-radius: 14px; font-size: 15px; line-height: 1.7;
 box-shadow: 0 0 20px #1e2433; border: 1px solid #2e3a59;
 }
 #imageInspector h3 { margin: 0 0 12px; color: #60a5fa; font-weight: 700; text-shadow: 0 0 10px #60a5faaa; }
 .inspector-controls { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
 #urlsBox { width: 100%; min-height: 120px; resize: vertical; margin-bottom: 15px; }
 .url-actions-container { margin-top: 25px; }
 .category { margin-bottom: 20px; padding: 15px; border-radius: 12px; background: rgba(0,0,0,0.2); border: 1px solid #2e3a59; }
 .category-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
 .category-header h4 { margin: 0; font-size: 16px; font-weight: bold; color: #fff; background: #60a5fa; display: inline-block; padding: 4px 10px; border-radius: 6px; }
 .toggle-btn { font-size: 12px; padding: 4px 10px; background: transparent; border: 1px solid #4b6cb7; color: #bbb; box-shadow: none; }
 .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px; }
 .card { background: #23262a; padding: 8px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 8px; align-items: center; transition: all 0.2s ease; border: 2px solid transparent; }
 .card:hover { transform: translateY(-4px); box-shadow: 0 6px 20px rgba(96,165,250,0.3); }
 .card.highlight-schinese {
 border-color: #60a5fa; box-shadow: 0 0 15px rgba(96, 165, 250, 0.6);
 }
 .thumb {
 width: 100%; height: 120px; object-fit: contain; border-radius: 8px;
 background: #121214; cursor: pointer;
 }
 .card .meta { width: 100%; font-size: 13px; color: #9aa4b2; text-align: center; }
 .card .actions { display: flex; gap: 8px; width: 100%; flex-wrap: wrap; justify-content: center; }
 .card .actions button { font-size: 12px; padding: 6px 10px; background: #4b6cb7; box-shadow: none; }
 .card .actions button:hover:not(:disabled) { background: #3b82f6; }
 
 #apiViewerContainer {
    background: #1e2433; border: 1px solid #2e3a59; border-radius: 14px; padding: 20px 25px;
 }
 #api-table {
    width: 100%; border-collapse: collapse; font-size: 14px;
 }
 #api-table td {
    padding: 8px 4px; vertical-align: top; border-bottom: 1px solid #23262a;
 }
 #api-table tr:last-child td { border-bottom: none; }
 #api-table td:nth-child(1) { font-weight: 500; color: #aeb9c7; width: 220px; word-break: break-all; }
 #api-table td:nth-child(2) { font-weight: 700; color: #e0e0e0; width: 180px; }
 #api-table td:nth-child(3) { color: #e0e0e0; word-break: break-word; }
 #api-table .api-section-header td {
    font-size: 16px; font-weight: bold; color: #60a5fa;
    padding-top: 20px !important; padding-bottom: 10px !important;
    border-bottom: 1px solid #60a5fa;
 }
 #api-table a { color: #60a5fa; text-decoration: none; }
 #api-table a:hover { text-decoration: underline; }
 #api-table code { background: #121417; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
 .language-table { width: 100%; margin-top: 5px; }
 .language-table th, .language-table td { text-align: left; padding: 4px; }
 .language-table th { color: #aeb9c7; }
 .language-table .support-cell { text-align: center; }
 .check-mark { color: #4ade80; }
 .platform-icon { height: 1em; vertical-align: text-bottom; margin-right: 4px; }
</style>
</head>
<body>

<div id="tutorial" class="hidden">
 <div class="tutorial-header">
 <h3>使用教程</h3>
 <button id="hideTutorialBtn" class="toggle-tutorial-btn">关闭</button>
 </div>
 <ul>
 <li>在输入框中输入游戏的 App ID。</li>
 <li>点击“获取”按钮加载数据。</li>
 <li>Logo 位置会根据官方数据自动设定。</li>
 <li>默认文字会自动填充，可自行修改（支持多行）。</li>
 <li>可以调整文字颜色、字号、字体和行间距。</li>
 <li>用鼠标拖动 Logo 或文字改变位置。</li>
 <li>按住 <kbd>Shift</kbd> 键可同步拖动 Logo 和文字。</li>
 <li>调整 Logo 缩放、背景渐变，完成后点击“保存图片”。</li>
 </ul>
</div>

<div class="main-container">
 <div class="header-container">
 <h1>枫小痕自己的steamdb</h1>
 <button id="showTutorialBtn" title="显示教程">?</button>
 </div>

 <div class="controls">
    <input type="text" id="appId" placeholder="请输入 Steam App ID" autocomplete="off" />
    <button id="fetchBtn" style="margin-left: 12px;">获取</button>
    <button id="saveBtn" disabled style="margin-left: auto;">保存图片</button>
    <button id="showApiBtn" disabled>查看 API 数据</button>
 </div>

 <div class="controls">
 <textarea id="customText" placeholder="输入自定义文字（支持多行）"></textarea>
 <input type="color" id="textColor" value="#ffffff" title="文字颜色" />
 <input type="number" id="textSize" value="24" min="8" max="200" title="文字大小" />
 <input type="number" id="lineSpacing" value="5" min="0" max="100" title="行间距" />
 <select id="textFont" title="字体">
 <option value="微软雅黑">微软雅黑</option> <option value="黑体">黑体</option> <option value="Arial">Arial</option> <option value="Times New Roman">Times New Roman</option>
 </select>
 </div>
 <div id="canvas-container">
 <canvas id="heroCanvas" width="1200" height="278" title="拖动Logo或文字微调位置"></canvas>
 </div>
 <div class="slider-container">
 <label for="scaleSlider">缩放 Logo:</label>
 <input type="range" id="scaleSlider" min="10" max="200" value="100" disabled />
 <span id="scalePercent">100%</span>
 </div>
 <div class="controls slider-container" style="margin-top: 15px;">
 <label for="overlaySlider">背景渐变:</label>
 <input type="range" id="overlaySlider" min="0" max="100" value="40" />
 <span id="overlayPercent">40%</span>
 <input type="color" id="gradientColor" value="#000000" title="渐变颜色" />
 <select id="gradientDirection" title="渐变方向">
 <option value="top-to-bottom">从上到下</option> <option value="bottom-to-top">从下到上</option> <option value="left-to-right">从左到右</option> <option value="right-to-left">从右到左</option> <option value="tl-to-br">左上到右下</option> <option value="tr-to-bl">右上到左下</option> <option value="bl-to-tr">左下到右上</option> <option value="br-to-tl">右下到左上</option>
 </select>
 </div>
 <div class="status-box"> <div id="loading"></div> <div id="error"></div> </div>
</div>

<div id="apiViewerContainer" style="display: none;">
 <table id="api-table"></table>
</div>

<div id="imageInspector" style="display: none;">
 <h3>图片探查器</h3>
 <div id="imageList"></div>
 <div class="url-actions-container">
 <div class="inspector-controls">
 <button id="copyAllBtn">复制全部链接</button>
 <button id="exportTxtBtn">导出为 .txt</button>
 </div>
 <textarea id="urlsBox" readonly placeholder="这里会显示识别到的所有图片链接..."></textarea>
 </div>
</div>


<script>
 const API_BASE = "https://api.steamcmd.net/v1/info/";
 const IMG_BASE = "https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/";
 const snapThreshold = 10;
 
 // DOM Elements
 const canvas = document.getElementById("heroCanvas");
 const ctx = canvas.getContext("2d");
 const errorBox = document.getElementById("error");
 const loadingBox = document.getElementById("loading");
 const scaleSlider = document.getElementById("scaleSlider");
 const scalePercent = document.getElementById("scalePercent");
 const saveBtn = document.getElementById("saveBtn");
 const overlaySlider = document.getElementById("overlaySlider");
 const overlayPercent = document.getElementById("overlayPercent");
 const imageInspector = document.getElementById("imageInspector");
 const imageList = document.getElementById("imageList");
 const urlsBox = document.getElementById("urlsBox");
 const gradientColorInput = document.getElementById("gradientColor");
 const gradientDirectionSelect = document.getElementById("gradientDirection");
 const showApiBtn = document.getElementById("showApiBtn");
 const apiViewerContainer = document.getElementById("apiViewerContainer");
 const apiTable = document.getElementById("api-table");
 
 // Global state variables
 let heroImg = new Image();
 let logoImg = new Image();
 let logoX = 0, logoY = 0, logoScale = 1;
 let customText = "", textColor = "#ffffff", textSize = 24, textFont = "微软雅黑";
 let textX = 20, textY = 20, lineSpacing = 5;
 let overlayOpacity = 0.4;
 let gradientColor = "#000000";
 let gradientDirection = "top-to-bottom";
 let dragging = false;
 let dragTarget = null;
 let dragOffsetX = 0, dragOffsetY = 0;

 function clearError() { errorBox.textContent = ""; }
 function showError(msg) { errorBox.textContent = msg; }
 function setLoading(msg) { loadingBox.textContent = msg; }
 function clearLoading() { loadingBox.textContent = ""; }
 function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

 function drawHero(img) { const cw = canvas.width, ch = canvas.height; ctx.clearRect(0, 0, cw, ch); if (!img.src) return; const scale = Math.max(cw / img.width, ch / img.height); const w = img.width * scale, h = img.height * scale; ctx.drawImage(img, (cw - w) / 2, (ch - h) / 2, w, h); if (overlayOpacity > 0) { let x0 = 0, y0 = 0, x1 = 0, y1 = 0; switch (gradientDirection) { case 'top-to-bottom': y1 = ch; break; case 'bottom-to-top': y0 = ch; break; case 'left-to-right': x1 = cw; break; case 'right-to-left': x0 = cw; break; case 'tl-to-br': x1 = cw; y1 = ch; break; case 'tr-to-bl': x0 = cw; y1 = ch; break; case 'bl-to-tr': y0 = ch; x1 = cw; break; case 'br-to-tl': x0 = cw; y0 = ch; break; } const g = ctx.createLinearGradient(x0, y0, x1, y1); g.addColorStop(0, hexToRgba(gradientColor, overlayOpacity)); g.addColorStop(1, hexToRgba(gradientColor, 0)); ctx.fillStyle = g; ctx.fillRect(0, 0, cw, ch); } }
 function drawLogo() { if (!logoImg.src || !logoImg.complete) return; ctx.drawImage(logoImg, logoX, logoY, logoImg.width * logoScale, logoImg.height * logoScale); }
 function drawText() { if (!customText) return; ctx.font = `${textSize}px "${textFont}"`; ctx.fillStyle = textColor; ctx.textBaseline = "top"; const lines = customText.split("\n"); lines.forEach((line, i) => { ctx.fillText(line, textX, textY + i * (textSize + lineSpacing)); }); }
 function drawAll() { drawHero(heroImg); drawLogo(); drawText(); }
 function initLogoPosition(logoPos) { const cw = canvas.width, ch = canvas.height; logoScale = (0.3 * cw) / logoImg.width; const widthPct = parseFloat(logoPos.width_pct); const heightPct = parseFloat(logoPos.height_pct); const pinned = (logoPos.pinned_position || "BottomRight").toLowerCase(); const logoW = logoImg.width * logoScale; const logoH = logoImg.height * logoScale; if (pinned.includes("right")) { logoX = cw - (widthPct / 100) * cw - logoW; } else { logoX = (widthPct / 100) * cw; } if (pinned.includes("bottom")) { logoY = ch - (heightPct / 100) * ch - logoH; } else { logoY = (heightPct / 100) * ch; } scaleSlider.value = Math.round(logoScale * 100); scalePercent.textContent = `${Math.round(logoScale * 100)}%`; scaleSlider.disabled = false; saveBtn.disabled = false; }
 function snapToCenterX(objX, objW) { const centerX = (canvas.width - objW) / 2; return Math.abs(objX - centerX) < snapThreshold ? centerX : objX; }
 function snapToCenterY(objY, objH) { const centerY = (canvas.height - objH) / 2; return Math.abs(objY - centerY) < snapThreshold ? centerY : objY; }

 canvas.addEventListener("mousedown", (e) => { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale; ctx.font = `${textSize}px "${textFont}"`; const lines = customText.split("\n"); const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0; const textH = lines.length * (textSize + lineSpacing) - lineSpacing; if (e.shiftKey) { dragTarget = "both"; dragOffsetX = mx - logoX; dragOffsetY = my - logoY; } else if (logoImg.src && mx >= logoX && mx <= logoX + logoW && my >= logoY && my <= logoY + logoH) { dragTarget = "logo"; dragOffsetX = mx - logoX; dragOffsetY = my - logoY; } else if (customText && mx >= textX && mx <= textX + textW && my >= textY && my <= textY + textH) { dragTarget = "text"; dragOffsetX = mx - textX; dragOffsetY = my - textY; } if (dragTarget) { dragging = true; canvas.style.cursor = "grabbing"; } });
 canvas.addEventListener("mousemove", (e) => { if (!dragging) return; const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale; ctx.font = `${textSize}px "${textFont}"`; const lines = customText.split("\n"); const textW = lines.length > 0 ? Math.max(...lines.map(line => ctx.measureText(line).width)) : 0; const textH = lines.length * (textSize + lineSpacing) - lineSpacing; if (dragTarget === "logo" || dragTarget === "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(logoImg.src) { newX = snapToCenterX(newX, logoW); newY = snapToCenterY(newY, logoH); } if (dragTarget === "logo") { logoX = newX; logoY = newY; } else { let offsetX = newX - logoX, offsetY = newY - logoY; logoX = newX; logoY = newY; textX += offsetX; textY += offsetY; } } if (dragTarget === "text" && dragTarget !== "both") { let newX = mx - dragOffsetX; let newY = my - dragOffsetY; if(customText) { newX = snapToCenterX(newX, textW); newY = snapToCenterY(newY, textH); } textX = newX; textY = newY; } drawAll(); });
 ["mouseup","mouseleave"].forEach(evt => { canvas.addEventListener(evt, () => { dragging = false; dragTarget = null; canvas.style.cursor = "grab"; }); });
 scaleSlider.addEventListener("input", (e) => { logoScale = e.target.value / 100; scalePercent.textContent = `${e.target.value}%`; drawAll(); });
 overlaySlider.addEventListener("input", (e) => { overlayOpacity = e.target.value / 100; overlayPercent.textContent = `${e.target.value}%`; drawAll(); });
 gradientColorInput.addEventListener("input", (e) => { gradientColor = e.target.value; drawAll(); });
 gradientDirectionSelect.addEventListener("change", (e) => { gradientDirection = e.target.value; drawAll(); });
 saveBtn.addEventListener("click", () => { const link = document.createElement("a"); link.download = `steam_${document.getElementById("appId").value.trim()}.png`; link.href = canvas.toDataURL("image/png"); link.click(); });
 document.getElementById("customText").addEventListener("input", (e) => { customText = e.target.value; drawAll(); });
 document.getElementById("textColor").addEventListener("input", (e) => { textColor = e.target.value; drawAll(); });
 document.getElementById("textSize").addEventListener("input", (e) => { textSize = parseInt(e.target.value, 10) || 24; drawAll(); });
 document.getElementById("textFont").addEventListener("change", (e) => { textFont = e.target.value; drawAll(); });
 document.getElementById("lineSpacing").addEventListener("input", (e) => { lineSpacing = parseInt(e.target.value, 10) || 0; drawAll(); });
 const tutorialPanel = document.getElementById('tutorial');
 document.getElementById('hideTutorialBtn').addEventListener('click', () => tutorialPanel.classList.add('hidden'));
 document.getElementById('showTutorialBtn').addEventListener('click', () => tutorialPanel.classList.remove('hidden'));
 
 function findImageCandidates(obj) { const results = new Set(); const imageRE = /\.(jpe?g|png|webp|gif)(\?|$)/i; function rec(v) { if (v == null) return; if (typeof v === 'string') { if (imageRE.test(v)) { results.add(v); } } else if (Array.isArray(v)) { for (const e of v) rec(e); } else if (typeof v === 'object') { for (const k in v) rec(v[k]); } } rec(obj); return [...results].map(s => s.split('#')[0].trim()).filter(Boolean); }
 
 function buildFullUrl(appid, candidate) {
     const trimmed = candidate.trim();
     if (/^https?:\/\//i.test(trimmed)) return trimmed;
     const clean = trimmed.replace(/^(\.\/|\/+)/, '');
     return `${IMG_BASE}${encodeURIComponent(appid)}/${clean}`;
 }

 function showImages(urls) {
     if (urls.length === 0) { 
         imageList.innerHTML = '<p>没有识别到任何图片资源。</p>'; 
         return; 
     } 
     imageList.innerHTML = `<p style="color: #60a5fa; text-align: center;">正在获取 ${urls.length} 张图片尺寸用于分组，请稍候...</p>`; 
     const categories = {}; 
     const promises = urls.map(u => new Promise(resolve => { 
         const img = new Image(); 
         img.src = u; 
         img.onload = () => resolve({ u, res: `${img.naturalWidth}x${img.naturalHeight}` }); 
         img.onerror = () => resolve({ u, res: '未知尺寸' }); 
     })); 
     Promise.all(promises).then(results => { 
         results.forEach(({ u, res }) => { 
             if (!categories[res]) categories[res] = []; 
             categories[res].push(u); 
         }); 
         renderCategories(categories); 
     }); 
 }
 function renderCategories(categories) {
     imageList.innerHTML = ''; 
     const sortedKeys = Object.keys(categories).sort((a, b) => { 
         if (a === '未知尺寸') return 1; 
         if (b === '未知尺寸') return -1; 
         const [wA, hA] = a.split('x').map(Number); 
         const [wB, hB] = b.split('x').map(Number); 
         const areaA = wA * hA;
         const areaB = wB * hB;
         return areaB - areaA; // Sort by image area descending
     }); 
     sortedKeys.forEach(res => { 
         const urls = categories[res]; 
         const wrapper = document.createElement('div'); 
         wrapper.className = 'category'; 
         const header = document.createElement('div'); 
         header.className = 'category-header'; 
         header.innerHTML = `<h4>分辨率: ${res} (${urls.length} 张)</h4><button class="toggle-btn">折叠</button>`; 
         wrapper.appendChild(header); 
         const cardGrid = document.createElement('div'); 
         cardGrid.className = 'card-grid'; 
         urls.forEach(u => { 
             const card = document.createElement('div'); 
             card.className = 'card'; 
             if (u.toLowerCase().includes('schinese')) { card.classList.add('highlight-schinese'); } 
             const langMatch = u.match(/(schinese|tchinese|english|japanese|koreana|french|german|spanish|latam)/i); 
             const lang = langMatch ? langMatch[0] : '通用'; 
             card.innerHTML = `<img src="${u}" alt="image" class="thumb" loading="lazy" onclick="this.style.objectFit = this.style.objectFit === 'contain' ? 'cover' : 'contain'"><div class="meta">${lang}</div><div class="actions"><button data-url="${u}" class="open-btn">打开</button><button data-url="${u}" class="copy-btn">复制</button><button data-url="${u}" class="dl-btn">下载</button></div>`; 
             cardGrid.appendChild(card); 
         }); 
         wrapper.appendChild(cardGrid); 
         imageList.appendChild(wrapper); 
         const toggleBtn = header.querySelector('.toggle-btn'); 
         toggleBtn.onclick = () => { 
             const isHidden = cardGrid.style.display === 'none'; 
             cardGrid.style.display = isHidden ? 'grid' : 'none'; 
             toggleBtn.textContent = isHidden ? '展开' : '折叠'; 
         }; 
     }); 
 }
 imageList.addEventListener('click', e => { const target = e.target; const url = target.dataset.url; if (!url) return; if (target.classList.contains('open-btn')) { window.open(url, '_blank'); } else if (target.classList.contains('copy-btn')) { navigator.clipboard.writeText(url).then(() => { setLoading('链接已复制!'); setTimeout(clearLoading, 1500); }); } else if (target.classList.contains('dl-btn')) { const a = document.createElement('a'); a.href = url; a.download = url.split('/').pop().split('?')[0] || `image.jpg`; a.target = '_blank'; a.click(); } });
 document.getElementById('copyAllBtn').addEventListener('click', () => { if (!urlsBox.value) return; navigator.clipboard.writeText(urlsBox.value).then(() => { setLoading('全部链接已复制!'); setTimeout(clearLoading, 1500); }); });
 document.getElementById('exportTxtBtn').addEventListener('click', () => { if (!urlsBox.value) return; const blob = new Blob([urlsBox.value], {type:'text/plain;charset=utf-8'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `steam_${document.getElementById("appId").value.trim()}_images.txt`; a.click(); URL.revokeObjectURL(a.href); });

 function buildApiTable(appData) {
    const data = appData.data || {};
    const common = appData.common || {};
    let html = '';
    
    const translations = {
        'name': '名称', 'type': 'APP 类型', 'steam_appid': 'APP ID', 'developers': '开发商', 'publishers': '发行商',
        'metacritic_name': 'Metacritic 名称', 'controller_support': '控制器支持', 'releasestate': '发布状态',
        'osarch': '系统架构', 'community_hub_visible': '社区中心可见', 'community_visible_stats': '社区中心可见统计',
        'workshop_visible': '创意工坊可见', 'release_date': '发售时间', 'oslist': '操作系统列表', 'osextended': '扩展操作系统',
        'review_score': '评测结果', 'review_percentage': '好评率', 'supported_languages': '支持的语言', 'primary_genre': '主要标签',
        'genres': '商店标签', 'categories': '商店分类', 'steam_deck_compatibility': 'Steam Deck 兼容性', 'test_timestamp': '测试时间戳',
        'tested_build_id': '测试版本ID', 'configuration': '配置', 'supported_input': '支持的输入', 'requires_manual_keyboard_invoke': '需要手动调用键盘',
        'requires_non_controller_launcher_nav': '启动器需要非手柄操作', 'primary_player_is_controller_slot_0': '主玩家是手柄0号位',
        'non_deck_display_glyphs': '显示非Deck图标', 'small_text': '文本过小', 'requires_internet_for_setup': '首次设置需要网络',
        'requires_internet_for_singleplayer': '单人模式需要网络', 'recommended_runtime': '推荐运行环境', 'requires_h264': '需要H264解码',
        'clienticon': '桌面图标', 'clienttga': '客户端标签', 'icon': '小图标', 'logo': '商店图标', 'logo_small': '商店小图标', 'clienticns': 'clienticns',
        'library_assets': '库资源', 'library_capsule': '封面图', 'library_hero': '库横幅', 'library_logo': '库图标', 'LinuxClientIcon': 'Linux 客户端图标',
        'library_header': 'library_header', 'main_capsule': 'main_capsule', 'small_capsule': '小预览图', 'header': '商店小图',
        'hero_capsule': 'hero_capsule', 'page_background_path': '页面背景路径', 'timestamp': '时间戳', 'movies': '宣传片',
        'screenshots': '截图', 'library_assets_full': '完整库资源', 'image': '图片', 'image2x': '2倍图', 'pinned_position': '固定位置',
        'width_pct': '宽度百分比', 'height_pct': '高度百分比', 'trailer_name': '预告片名称', 'trailer_480p': '480p预告片',
        'trailer_max': '最高画质预告片', 'video': '视频', 'webm': 'WebM格式', 'mp4': 'MP4格式', 'controllertagwizard': '手柄标签向导',
        'detected_technologies': '检测到的组件', 'library_hero_blur': 'library_hero_blur', 'logo_position': 'logo_position',
        'social media': 'Social Media', 'steam release date': 'Steam发售日期', 'store asset modification time': '存储资产修改时间',
        'first seen on steamdb': 'First seen on SteamDB', 'category': 'category', 'steamos_compatibility': 'SteamOS 兼容性',
        'requires_voice_files': '需要语音文件', 'gamescope_frame_limiter_not_supported': '不支持Gamescope帧率限制', 'hdr_support': 'HDR支持',
        'last_changenumber': 'Last Changenumber', 'last_record_update': '最后更新时间', 'franchise': '系列作品'
    };
    
    const pinnedOrder = [
        { key: 'steam_appid', en: 'App ID', zh: 'APP ID', source: 'data' },
        { key: 'type', en: 'App Type', zh: 'APP 类型', source: 'common' },
        { key: 'developers', en: 'Developer', zh: '开发商', source: 'data' },
        { key: 'publishers', en: 'Publisher', zh: '发行商', source: 'data' },
        { key: 'franchise', en: 'Franchise', zh: '系列作品', source: 'data' },
        { key: 'platforms', en: 'Supported Systems', zh: '支持的操作系统', source: 'data' },
        { key: 'detected_technologies', en: 'Technologies', zh: 'Technologies', source: 'common' },
        { key: 'last_changenumber', en: 'Last Changenumber', zh: 'Last Changenumber', source: 'common' },
        { key: 'last_record_update', en: 'Last Record Update', zh: '最后更新时间', source: 'common' },
        { key: 'release_date', en: 'Release Date', zh: '发售时间', source: 'data' }
    ];
    
    let allData = {};
    const processObject = (obj, prefix = '') => {
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                const newKey = prefix ? `${prefix}.${key}` : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    processObject(value, newKey);
                } else {
                    allData[newKey] = value;
                }
            }
        }
    };
    processObject({ ...data, ...common });

    const formatValue = (key, value) => {
        if (value === true) return '✅ 是';
        if (value === false) return '❌ 否';
        if (typeof value === 'boolean') return value ? '✅ 是' : '❌ 否';
        if ((key.toLowerCase().includes('date') || key.toLowerCase().includes('update') || key.toLowerCase().includes('timestamp')) && typeof value === 'number') {
            return new Date(value * 1000).toUTCString();
        }
        if (key.toLowerCase().includes('date') && typeof value === 'object' && value.date) {
             return new Date(value.date * 1000).toUTCString();
        }
        if(key === 'Supported Systems'){
            return (value || []).map(sys => `<img src="https://steamdb.info/static/img/os/${sys}.svg" title="${sys}" class="platform-icon" alt="${sys}">`).join(' ');
        }
        if (key === 'controller_support' && value === 'full') return '完全支持';
        if (Array.isArray(value) && value.every(item => typeof item === 'string' && item.startsWith('http'))) {
            return value.map(url => `<a href="${url}" target="_blank">${url.split('/')[2]}</a>`).join('<br>');
        }
        return value;
    };

    const addSection = (title) => { html += `<tr><td colspan="3" class="api-section-header">${title}</td></tr>`; };
    const addRow = (en, zh, val) => {
         if (val === undefined || val === null || val === '' || (Array.isArray(val) && val.length === 0)) return;
         html += `<tr><td>${en}</td><td>${zh}</td><td>${formatValue(en, val)}</td></tr>`;
    };

    // Pinned Section
    addSection(data.name || '基本信息');
    const processedKeys = new Set();
    pinnedOrder.forEach(item => {
        const sourceObj = item.source === 'data' ? data : common;
        let value = sourceObj[item.key];
        if (value !== undefined) {
             if (item.key === 'platforms') value = Object.entries(value || {}).filter(([_,v])=>v).map(([k])=>k);
             else if (item.key === 'developers' || item.key === 'publishers') value = (value || []).join(', ');
             else if (item.key === 'detected_technologies') value = (value || []).map(t => t.name).join(', ');
             addRow(item.en, item.zh, value);
             processedKeys.add(item.key);
        }
    });

    // Detailed Information Section
    addSection("附加信息");
    const detailedOrder = ['developers','metacritic_name','controller_support','community_visible_stats','releasestate','publishers','release_date','osarch','community_hub_visible','primary_genre','genres','last_record_update','osextended','review_score','review_percentage','detected_technologies','steam_deck_compatibility','controllertagwizard'];
    detailedOrder.forEach(key => {
        if(allData.hasOwnProperty(key) && !processedKeys.has(key)){
            addRow(key, translations[key] || key, allData[key]);
            processedKeys.add(key);
        }
    });

    // Language Section
    const langValue = (data || {}).supported_languages;
    if (typeof langValue === 'string' && langValue) {
        addSection("支持的语言");
        const langs = langValue.split(',').map(s=>s.trim()).filter(Boolean);
        let langTable = '<table class="language-table"><thead><tr><th>语言</th><th>界面</th><th>音频</th><th>字幕</th></tr></thead><tbody>';
        langs.forEach(langStr => {
            const hasAudio = langStr.includes('*');
            const name = langStr.replace(/<strong>\*<\/strong>/i, '').replace(/<br>/i, '').trim();
            langTable += `<tr><td>${name}</td><td class="support-cell"><span class="check-mark">✔</span></td><td class="support-cell">${hasAudio ? '<span class="check-mark">✔</span>' : ''}</td><td class="support-cell"><span class="check-mark">✔</span></td></tr>`;
        });
        langTable += '</tbody></table>';
        html += `<tr><td colspan="3">${langTable}</td></tr>`;
        processedKeys.add('supported_languages');
    }

    // Assets section
    addSection("资产");
    const assetKeys = Object.keys(allData).filter(k => k.startsWith('common.') || k.startsWith('library_assets_full'));
    for(const key of Object.keys(allData).sort()){
        if(!processedKeys.has(key)){
             addRow(key, translations[key] || key, allData[key]);
        }
    }
    
    apiTable.innerHTML = html;
 }
 
 async function fetchData(appId) {
     clearError(); setLoading("正在请求API...");
     saveBtn.disabled = true; scaleSlider.disabled = true; showApiBtn.disabled = true;
     apiViewerContainer.style.display = 'none'; showApiBtn.textContent = '查看 API 数据';
     imageInspector.style.display = 'none'; imageList.innerHTML = ''; urlsBox.value = '';
     try {
         const res = await fetch(API_BASE + appId);
         if (!res.ok) throw new Error(`API 请求失败: ${res.status}`);
         const json = await res.json();
         
         const appData = json.data?.[appId];
         if (!appData) { throw new Error(json.message || "未找到游戏数据或API返回格式无效"); }

         buildApiTable(appData);
         showApiBtn.disabled = false;
         
         setLoading("正在加载拼图资源...");
         
         let gameName = appData.common?.name_localized?.schinese || appData.common?.metacritic_name || appData.common?.name || "";
         customText = `3DM《${gameName}》专区`;
         document.getElementById("customText").value = customText;
         
         const assetsFull = appData.common?.library_assets_full;
         if (!assetsFull) throw new Error("缺少 library_assets_full 数据");
         
         const heroPath = assetsFull.library_hero?.image?.english;
         let logoPath = assetsFull.library_logo?.image?.english;
         if (!heroPath) throw new Error("未找到 library_hero 图片");
         
         const heroUrl = IMG_BASE + appId + "/" + heroPath;
         let logoUrl = logoPath ? IMG_BASE + appId + "/" + logoPath : `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`;
         
         heroImg = new Image(); heroImg.crossOrigin = "anonymous"; heroImg.src = heroUrl;
         logoImg = new Image(); logoImg.crossOrigin = "anonymous"; logoImg.src = logoUrl;
         
         await Promise.all([
             new Promise((res, rej) => { heroImg.onload = res; heroImg.onerror = () => rej(new Error('背景图加载失败')); }),
             new Promise((res) => { logoImg.onload = res; logoImg.onerror = () => { logoImg.src = `https://cdn.cloudflare.steamstatic.com/steam/apps/${appId}/header.jpg`; logoImg.onload = res; logoImg.onerror = res; };}),
         ]);
         
         drawHero(heroImg);
         if(logoImg.complete && logoImg.naturalWidth > 0) {
             const logoPos = assetsFull.library_logo?.logo_position;
             if (logoPos) {
                 initLogoPosition(logoPos);
             } else {
                 logoScale = (0.2 * canvas.width) / logoImg.width;
                 logoX = canvas.width - logoImg.width * logoScale - 20;
                 logoY = canvas.height - logoImg.height * logoScale - 20;
                 scaleSlider.value = Math.round(logoScale * 100);
                 scalePercent.textContent = `${Math.round(logoScale * 100)}%`;
                 scaleSlider.disabled = false;
                 saveBtn.disabled = false;
             }
         } else { logoImg.src = ''; scaleSlider.disabled = true; }

         ctx.font = `${textSize}px "${textFont}"`;
         const lines = customText.split("\n");
         const textW = Math.max(...lines.map(line => ctx.measureText(line).width));
         const textH = lines.length * (textSize + lineSpacing) - lineSpacing;
         textX = (canvas.width - textW) / 2;
         textY = (canvas.height - textH) / 2 + 30;
         drawAll();

         setLoading("正在解析图片资源...");
         const candidates = findImageCandidates(json);
         const allImageUrls = [...new Set(candidates.map(c => buildFullUrl(appId, c)))];
         imageInspector.style.display = 'block';
         if (allImageUrls.length > 0) {
             urlsBox.value = allImageUrls.join('\n');
             showImages(allImageUrls);
         } else {
             imageList.innerHTML = '<p>未能自动识别到其他图片资源。</p>';
         }
         clearLoading();
     } catch (e) {
         showError(e.message || "未知错误");
         clearLoading();
     }
 }

 document.getElementById("fetchBtn").addEventListener("click", () => {
     const id = document.getElementById("appId").value.trim();
     if (!id) { showError("请输入有效的 Steam App ID"); return; }
     fetchData(id);
 });
 
 showApiBtn.addEventListener('click', () => {
     if (apiViewerContainer.style.display === 'none') {
         apiViewerContainer.style.display = 'block';
         showApiBtn.textContent = '隐藏 API 数据';
     } else {
         apiViewerContainer.style.display = 'none';
         showApiBtn.textContent = '查看 API 数据';
     }
 });
 
 window.addEventListener('DOMContentLoaded', () => {
     const params = new URLSearchParams(window.location.search);
     const appIdFromUrl = params.get("appid");
     if (appIdFromUrl) {
         document.getElementById("appId").value = appIdFromUrl;
         fetchData(appIdFromUrl);
     }
 });

</script>
</body>
</html>
